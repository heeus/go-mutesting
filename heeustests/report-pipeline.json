{"stats":{"totalMutantsCount":285,"killedCount":201,"notCoveredCount":0,"escapedCount":52,"errorCount":0,"skippedCount":32,"timeOutCount":0,"msi":0.8175438596491228,"mutationCodeCoverage":0,"coveredCodeMsi":0},"escaped":[{"mutator":{"mutatorName":"branch/else","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\n\t\t}\n\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,89 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\n+\t\t}\n+\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.0\" with checksum 6285ebf2cdf3853a29a8dbeeb80be632\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t\tbreak\n\t}\n\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t\tbreak\n+\t}\n+\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.6\" with checksum 690c3a7cb5c3f6ef2ec2b3b8a82db250\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 0),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 0),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.7\" with checksum 1f3a79cb013c656b1a6e90981294c558\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 2),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 2),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.10\" with checksum a938075b97aea5e3a5f84de165e9b674\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\t_, _ = pipeline.stdout, first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\t_, _ = pipeline.stdout, first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.15\" with checksum 1e1782d36d807597d4153aa46d68226d\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\t_, _ = pstruct.WriteString, first.String\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\t_, _ = pstruct.WriteString, first.String\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.16\" with checksum d53d835defe41c70eb6e4ca6b3c463e7\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\t_, _, _, _ = pipeline.wctx, NewWorkpieceContext, name, pstruct.String\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\t_, _, _, _ = pipeline.wctx, NewWorkpieceContext, name, pstruct.String\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.19\" with checksum 38fca4aa5f1cbb3e93e45a229c50aca2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\t_ = pstruct.WriteString\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\t_ = pstruct.WriteString\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.23\" with checksum c967680dfdb758a5c15b182265acfe17\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\t_, _ = pstruct.WriteString, next.String\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\t_, _ = pstruct.WriteString, next.String\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.24\" with checksum f4253d8a3a179aaf1d23f9e732f2b9eb\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\t_, _ = op.storages, storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\t_, _ = op.storages, storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.25\" with checksum 77c9cfcd008fc9808892a090a37618fd\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\t_, _ = op.wctx, pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\t_, _ = op.wctx, pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.27\" with checksum c51c44c65bb21765a7d3edb0653ea569\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.28\" with checksum 7f3ff15d37d84093d093936a8e845a27\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n * @author Maxim Geraskin\r\n *\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype asyncSwitchOperator struct {\r\n\tswitchLogic ISwitch\r\n\tbranches    map[string]IAsyncPipeline\r\n\tAsyncNOOP\r\n}\r\n\r\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n\tres := \u0026asyncSwitchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n\tfirstBranch(res)\r\n\tfor _, branch := range otherBranches {\r\n\t\tbranch(res)\r\n\t}\r\n\treturn res\r\n}\r\n\r\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n\r\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tbranchName, err := as.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn work, err\r\n\t}\r\n\treturn nil, as.branches[branchName].SendAsync(work)\r\n}\r\n\r\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n\treturn func(as *asyncSwitchOperator) {\r\n\t\tas.branches[name] = branch\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n * @author Maxim Geraskin\n *\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype asyncSwitchOperator struct {\n\tswitchLogic ISwitch\n\tbranches    map[string]IAsyncPipeline\n\tAsyncNOOP\n}\n\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n\tres := \u0026asyncSwitchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]IAsyncPipeline)}\n\tfirstBranch(res)\n\tfor _, branch := range otherBranches {\n\t\tbranch(res)\n\t}\n\treturn res\n}\n\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tbranchName, err := as.switchLogic.Switch(work)\n\tif err != nil {\n\t\t_, _ = work, err\n\n\t}\n\treturn nil, as.branches[branchName].SendAsync(work)\n}\n\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n\treturn func(as *asyncSwitchOperator) {\n\t\tas.branches[name] = branch\n\t}\n}\n","originalFilePath":"async-switch-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,42 +1,43 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- * @author Maxim Geraskin\r\n- *\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type asyncSwitchOperator struct {\r\n-\tswitchLogic ISwitch\r\n-\tbranches    map[string]IAsyncPipeline\r\n-\tAsyncNOOP\r\n-}\r\n-\r\n-func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n-\tres := \u0026asyncSwitchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n-\tfirstBranch(res)\r\n-\tfor _, branch := range otherBranches {\r\n-\t\tbranch(res)\r\n-\t}\r\n-\treturn res\r\n-}\r\n-\r\n-type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n-\r\n-func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tbranchName, err := as.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn work, err\r\n-\t}\r\n-\treturn nil, as.branches[branchName].SendAsync(work)\r\n-}\r\n-\r\n-func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n-\treturn func(as *asyncSwitchOperator) {\r\n-\t\tas.branches[name] = branch\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ * @author Maxim Geraskin\n+ *\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type asyncSwitchOperator struct {\n+\tswitchLogic ISwitch\n+\tbranches    map[string]IAsyncPipeline\n+\tAsyncNOOP\n+}\n+\n+func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n+\tres := \u0026asyncSwitchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]IAsyncPipeline)}\n+\tfirstBranch(res)\n+\tfor _, branch := range otherBranches {\n+\t\tbranch(res)\n+\t}\n+\treturn res\n+}\n+\n+type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n+\n+func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tbranchName, err := as.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\t_, _ = work, err\n+\n+\t}\n+\treturn nil, as.branches[branchName].SendAsync(work)\n+}\n+\n+func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n+\treturn func(as *asyncSwitchOperator) {\n+\t\tas.branches[name] = branch\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-switch-impl.go.0\" with checksum 4f47d386af74d129d2179d642acd23d8\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.7\" with checksum 809f52c88159f605c09b628657335a21\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t_ = t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t_ = t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.13\" with checksum 7af00fcd308a5fc7a07ddae33c37f435\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif true \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif true \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.16\" with checksum ec78a344e777546d6c67a3635a91317a\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.18\" with checksum b7db6dfa89916d6f997149142a789db4\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.19\" with checksum 6c2c9539470650ff4a4ec1778228716c\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.20\" with checksum add512e9e9cbba4ea1b3e994a16bb766\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.21\" with checksum 5038d6945eb91a04986472e403744492\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 1 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 1 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.23\" with checksum e513b86f54601542d29ab7e7866d94c7\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\t_ = flushTimer.stop\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\t_ = flushTimer.stop\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.27\" with checksum 0e0a247a605d3b0c92466de1de93a33c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\t_ = t.active\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\t_ = t.active\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.35\" with checksum 8d20312d2659ac9c3e6dae87b3a6405f\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 2\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 0\n\tqsiMustNotExist = 1\n\tqsiCanExist     = 2\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 2\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 0\n+\tqsiMustNotExist = 1\n+\tqsiCanExist     = 2\n+)\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.0\" with checksum cdc1977415836de76a18670c55625a96\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 3\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = -1\n\tqsiMustNotExist = 1\n\tqsiCanExist     = 2\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 3\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = -1\n+\tqsiMustNotExist = 1\n+\tqsiCanExist     = 2\n+)\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.1\" with checksum 1f4b2ae9da42bd1a1bd9bfb691b2e9b7\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 3\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 0\n\tqsiMustNotExist = 1\n\tqsiCanExist     = 1\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 3\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 0\n+\tqsiMustNotExist = 1\n+\tqsiCanExist     = 1\n+)\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.3\" with checksum 13ccc57906c084d70f19b3fce70f3702\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 3\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 0\n\tqsiMustNotExist = 2\n\tqsiCanExist     = 2\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 3\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 0\n+\tqsiMustNotExist = 2\n+\tqsiCanExist     = 2\n+)\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.6\" with checksum e731cd36ecb204e98634655f71ed5b12\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 3\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 0\n\tqsiMustNotExist = 1\n\tqsiCanExist     = 3\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 3\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 0\n+\tqsiMustNotExist = 1\n+\tqsiCanExist     = 3\n+)\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.7\" with checksum f9916ee54b8e25a8e94957233a51e880\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)-len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)-len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.0\" with checksum aa571ff5a88e77dbb8c9f0487ec3344e\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)-len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)-len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.1\" with checksum 6bd7d3f05cea379cc0b79a73e8d95ac3\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.10\" with checksum 0aa1885b521b6b1ae7a5dd45c6d8cd75\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.11\" with checksum 17bd94c9b7457d941969c6b490dd9fcc\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.13\" with checksum 6708a20d9ad27f7a44a7a28c2b6fb854\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e= maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e= maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.21\" with checksum f6e43836d6ef776617c9bfb4a5a7ca5e\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif true \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif true \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.22\" with checksum 007dc6f5ad3ca690eb65b8b99595c5a5\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 true {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 true {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.25\" with checksum c9c1c8d3799aa9f6009d6cb3d0aad669\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || false {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || false {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.27\" with checksum 5f9a4691f89922d6aff7b53bff7e69f2\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 2\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 2\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.37\" with checksum bea9ca59a8e39af5ed374fb1a89ed296\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 1),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 1),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.8\" with checksum 71b729847e7825236dd878e6ee785f08\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\t_ = qs.addedItems\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\t_ = qs.addedItems\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.14\" with checksum 649d4a32a75e3bc21e7d1d41d1a810f7\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t\tbreak\n\t}\n\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,92 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t\tbreak\n+\t}\n+\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.6\" with checksum a0aa278378077c6763c9c2cae5f3f9f0\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 0),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 0),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.7\" with checksum 202f05f2921a1bc8d5effa043eb48c1f\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 2),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 2),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.10\" with checksum c0edd057b35e27a656acde63cbc44a2e\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\t_ = first\n\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,91 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\t_ = first\n+\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.13\" with checksum 7ece79766780928875756018729f3b57\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\t_, _ = pipeline.stdout, first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\t_, _ = pipeline.stdout, first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.16\" with checksum dae8cd08263fbf4781350ae10920d1f5\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\t_ = next\n\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,91 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\t_ = next\n+\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.20\" with checksum 8b67e15e159dbcea211bfc3c8c3ee1bd\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.8\" with checksum 144022472f2a6b11f7184765657b5888\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tbreak\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.9\" with checksum 7da23ad20a545fcbc218dbcbf936505e\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 0),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 0),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.16\" with checksum 9149bbc8dbb94818597f28d86adf92c5\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 2),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 2),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.19\" with checksum f27c7877a4eb6541b663cfb7d386e4f6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 2),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 2),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.20\" with checksum 8aabfb19eff82930cd87aa63761113fc\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\t_, _ = wo.err, ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\t_, _ = wo.err, ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"FAIL \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.24\" with checksum e1a0267f9869f96d9817fd167e16fb11\n"}],"timeouted":null,"killed":[{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\t_, _ = puller_async, op\n\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,89 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\t_, _ = puller_async, op\n+\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.1\" with checksum 9096cc73d49d8d870a2e51793fd0d02a\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\t_ = p.ctx.Err\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\t_ = p.ctx.Err\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.2\" with checksum ccff06bc07ebdc4645963f93eb69765e\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tbreak\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tbreak\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.3\" with checksum fdd96a2a795326d2f13e692c4873650d\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\tbreak\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\tbreak\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.4\" with checksum c757e2c4f7f6fb77710ba5b1d7c418e3\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tbreak\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tbreak\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.5\" with checksum 6d0dc94122f01a6d3a593592759eb345\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 0),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 0),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.8\" with checksum 7d9a19d53910eab612983f577f98a868\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 2),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 2),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.11\" with checksum 609ae2b66ce669e4d25d76d65de2dacf\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[1] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[1] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.12\" with checksum 17e09d97da07c711926f07881743f2f9\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\t_, _ = first.Stdin, pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\t_, _ = first.Stdin, pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.14\" with checksum f59500c4c3f4393c35bd3f584e30253b\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\t_, _ = others, others\n\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\t_, _ = others, others\n+\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.17\" with checksum dcb312e308f0079669a879f18e39f36c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\t_, _ = pipeline.stdout, last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\t_, _ = pipeline.stdout, last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.18\" with checksum 3db8ad0120d96d3d6046e9c0c76532d0\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\t_, _ = next.Stdin, last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\t_, _ = next.Stdin, last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.20\" with checksum d41e87e6fc876e9e850c40911e4033d7\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\t_, _ = last, next\n\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,89 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\t_, _ = last, next\n+\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.22\" with checksum 26bcf414b794223e72001e3d900b73f0\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\t_, _ = op.ctx, ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\t_, _ = op.ctx, ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.26\" with checksum f8fe39bc6ba25e7bb95cfbfb6b81baf2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\t_ = p.stdin\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\twork.Release()\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\t_ = p.stdin\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\twork.Release()\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.29\" with checksum fb3ba997617554d002870a3e222bd78a\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype AsyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026AsyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tothers = append(others, releaser())\r\n\tfor _, next := range others {\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n\t\t\tgo puller_async(op)\r\n\t\t} else {\r\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n\t\t}\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tselect {\r\n\tcase p.stdin \u003c- work:\r\n\t\treturn nil\r\n\tcase item := \u003c-p.stdout:\r\n\t\treturn item.(error) // only error is possible after releaser\r\n\t}\r\n}\r\n\r\nfunc (p AsyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc releaser() *WiredOperator {\r\n\treturn WireAsyncOperator(\r\n\t\t\"releaser\",\r\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n\t\t\twork.Release()\r\n\t\t\treturn nil, nil\r\n\t\t}))\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype AsyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026AsyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tothers = append(others, releaser())\n\tfor _, next := range others {\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n\t\t\tgo puller_async(op)\n\t\t} else {\n\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n\t\t}\n\t}\n\treturn pipeline\n}\n\nfunc (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tselect {\n\tcase p.stdin \u003c- work:\n\t\treturn nil\n\tcase item := \u003c-p.stdout:\n\t\treturn item.(error) // only error is possible after releaser\n\t}\n}\n\nfunc (p AsyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc releaser() *WiredOperator {\n\treturn WireAsyncOperator(\n\t\t\"releaser\",\n\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n\t\t\t_ = work.Release\n\t\t\treturn nil, nil\n\t\t}))\n}\n","originalFilePath":"async-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,88 +1,88 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type AsyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026AsyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tothers = append(others, releaser())\r\n-\tfor _, next := range others {\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\r\n-\t\t\tgo puller_async(op)\r\n-\t\t} else {\r\n-\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\r\n-\t\t}\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tselect {\r\n-\tcase p.stdin \u003c- work:\r\n-\t\treturn nil\r\n-\tcase item := \u003c-p.stdout:\r\n-\t\treturn item.(error) // only error is possible after releaser\r\n-\t}\r\n-}\r\n-\r\n-func (p AsyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func releaser() *WiredOperator {\r\n-\treturn WireAsyncOperator(\r\n-\t\t\"releaser\",\r\n-\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\r\n-\t\t\twork.Release()\r\n-\t\t\treturn nil, nil\r\n-\t\t}))\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type AsyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewAsyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) IAsyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026AsyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tothers = append(others, releaser())\n+\tfor _, next := range others {\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tif _, ok := op.Operator.(IAsyncOperator); ok {\n+\t\t\tgo puller_async(op)\n+\t\t} else {\n+\t\t\tpanic(\"WiredOperator\u003cISyncOperator\u003e not allowed in async pipeline\")\n+\t\t}\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p AsyncPipeline) SendAsync(work IWorkpiece) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tselect {\n+\tcase p.stdin \u003c- work:\n+\t\treturn nil\n+\tcase item := \u003c-p.stdout:\n+\t\treturn item.(error) // only error is possible after releaser\n+\t}\n+}\n+\n+func (p AsyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func releaser() *WiredOperator {\n+\treturn WireAsyncOperator(\n+\t\t\"releaser\",\n+\t\tNewAsyncOp(func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error) {\n+\t\t\t_ = work.Release\n+\t\t\treturn nil, nil\n+\t\t}))\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-pipeline-impl.go.30\" with checksum 68d57cc87630e875e97ef51cfadd16b4\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n * @author Maxim Geraskin\r\n *\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype asyncSwitchOperator struct {\r\n\tswitchLogic ISwitch\r\n\tbranches    map[string]IAsyncPipeline\r\n\tAsyncNOOP\r\n}\r\n\r\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n\tres := \u0026asyncSwitchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n\tfirstBranch(res)\r\n\tfor _, branch := range otherBranches {\r\n\t\tbranch(res)\r\n\t}\r\n\treturn res\r\n}\r\n\r\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n\r\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tbranchName, err := as.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn work, err\r\n\t}\r\n\treturn nil, as.branches[branchName].SendAsync(work)\r\n}\r\n\r\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n\treturn func(as *asyncSwitchOperator) {\r\n\t\tas.branches[name] = branch\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n * @author Maxim Geraskin\n *\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype asyncSwitchOperator struct {\n\tswitchLogic ISwitch\n\tbranches    map[string]IAsyncPipeline\n\tAsyncNOOP\n}\n\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n\tres := \u0026asyncSwitchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]IAsyncPipeline)}\n\tfirstBranch(res)\n\tfor _, branch := range otherBranches {\n\t\tbreak\n\t\tbranch(res)\n\t}\n\n\treturn res\n}\n\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tbranchName, err := as.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn work, err\n\t}\n\treturn nil, as.branches[branchName].SendAsync(work)\n}\n\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n\treturn func(as *asyncSwitchOperator) {\n\t\tas.branches[name] = branch\n\t}\n}\n","originalFilePath":"async-switch-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,42 +1,44 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- * @author Maxim Geraskin\r\n- *\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type asyncSwitchOperator struct {\r\n-\tswitchLogic ISwitch\r\n-\tbranches    map[string]IAsyncPipeline\r\n-\tAsyncNOOP\r\n-}\r\n-\r\n-func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n-\tres := \u0026asyncSwitchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n-\tfirstBranch(res)\r\n-\tfor _, branch := range otherBranches {\r\n-\t\tbranch(res)\r\n-\t}\r\n-\treturn res\r\n-}\r\n-\r\n-type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n-\r\n-func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tbranchName, err := as.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn work, err\r\n-\t}\r\n-\treturn nil, as.branches[branchName].SendAsync(work)\r\n-}\r\n-\r\n-func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n-\treturn func(as *asyncSwitchOperator) {\r\n-\t\tas.branches[name] = branch\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ * @author Maxim Geraskin\n+ *\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type asyncSwitchOperator struct {\n+\tswitchLogic ISwitch\n+\tbranches    map[string]IAsyncPipeline\n+\tAsyncNOOP\n+}\n+\n+func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n+\tres := \u0026asyncSwitchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]IAsyncPipeline)}\n+\tfirstBranch(res)\n+\tfor _, branch := range otherBranches {\n+\t\tbreak\n+\t\tbranch(res)\n+\t}\n+\n+\treturn res\n+}\n+\n+type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n+\n+func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tbranchName, err := as.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn work, err\n+\t}\n+\treturn nil, as.branches[branchName].SendAsync(work)\n+}\n+\n+func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n+\treturn func(as *asyncSwitchOperator) {\n+\t\tas.branches[name] = branch\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-switch-impl.go.1\" with checksum 1b480f413e28100ef28ffec1dcc14e32\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n * @author Maxim Geraskin\r\n *\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype asyncSwitchOperator struct {\r\n\tswitchLogic ISwitch\r\n\tbranches    map[string]IAsyncPipeline\r\n\tAsyncNOOP\r\n}\r\n\r\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n\tres := \u0026asyncSwitchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n\tfirstBranch(res)\r\n\tfor _, branch := range otherBranches {\r\n\t\tbranch(res)\r\n\t}\r\n\treturn res\r\n}\r\n\r\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n\r\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tbranchName, err := as.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn work, err\r\n\t}\r\n\treturn nil, as.branches[branchName].SendAsync(work)\r\n}\r\n\r\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n\treturn func(as *asyncSwitchOperator) {\r\n\t\tas.branches[name] = branch\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n * @author Maxim Geraskin\n *\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype asyncSwitchOperator struct {\n\tswitchLogic ISwitch\n\tbranches    map[string]IAsyncPipeline\n\tAsyncNOOP\n}\n\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n\tres := \u0026asyncSwitchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]IAsyncPipeline)}\n\t_, _ = firstBranch, res\n\n\tfor _, branch := range otherBranches {\n\t\tbranch(res)\n\t}\n\treturn res\n}\n\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tbranchName, err := as.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn work, err\n\t}\n\treturn nil, as.branches[branchName].SendAsync(work)\n}\n\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n\treturn func(as *asyncSwitchOperator) {\n\t\tas.branches[name] = branch\n\t}\n}\n","originalFilePath":"async-switch-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,42 +1,43 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- * @author Maxim Geraskin\r\n- *\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type asyncSwitchOperator struct {\r\n-\tswitchLogic ISwitch\r\n-\tbranches    map[string]IAsyncPipeline\r\n-\tAsyncNOOP\r\n-}\r\n-\r\n-func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n-\tres := \u0026asyncSwitchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n-\tfirstBranch(res)\r\n-\tfor _, branch := range otherBranches {\r\n-\t\tbranch(res)\r\n-\t}\r\n-\treturn res\r\n-}\r\n-\r\n-type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n-\r\n-func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tbranchName, err := as.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn work, err\r\n-\t}\r\n-\treturn nil, as.branches[branchName].SendAsync(work)\r\n-}\r\n-\r\n-func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n-\treturn func(as *asyncSwitchOperator) {\r\n-\t\tas.branches[name] = branch\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ * @author Maxim Geraskin\n+ *\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type asyncSwitchOperator struct {\n+\tswitchLogic ISwitch\n+\tbranches    map[string]IAsyncPipeline\n+\tAsyncNOOP\n+}\n+\n+func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n+\tres := \u0026asyncSwitchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]IAsyncPipeline)}\n+\t_, _ = firstBranch, res\n+\n+\tfor _, branch := range otherBranches {\n+\t\tbranch(res)\n+\t}\n+\treturn res\n+}\n+\n+type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n+\n+func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tbranchName, err := as.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn work, err\n+\t}\n+\treturn nil, as.branches[branchName].SendAsync(work)\n+}\n+\n+func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n+\treturn func(as *asyncSwitchOperator) {\n+\t\tas.branches[name] = branch\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-switch-impl.go.2\" with checksum 165808b53edb1fb9043536d6535b7e12\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n * @author Maxim Geraskin\r\n *\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype asyncSwitchOperator struct {\r\n\tswitchLogic ISwitch\r\n\tbranches    map[string]IAsyncPipeline\r\n\tAsyncNOOP\r\n}\r\n\r\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n\tres := \u0026asyncSwitchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n\tfirstBranch(res)\r\n\tfor _, branch := range otherBranches {\r\n\t\tbranch(res)\r\n\t}\r\n\treturn res\r\n}\r\n\r\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n\r\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tbranchName, err := as.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn work, err\r\n\t}\r\n\treturn nil, as.branches[branchName].SendAsync(work)\r\n}\r\n\r\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n\treturn func(as *asyncSwitchOperator) {\r\n\t\tas.branches[name] = branch\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n * @author Maxim Geraskin\n *\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype asyncSwitchOperator struct {\n\tswitchLogic ISwitch\n\tbranches    map[string]IAsyncPipeline\n\tAsyncNOOP\n}\n\nfunc AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n\tres := \u0026asyncSwitchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]IAsyncPipeline)}\n\tfirstBranch(res)\n\tfor _, branch := range otherBranches {\n\t\t_, _ = branch, res\n\n\t}\n\treturn res\n}\n\ntype AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n\nfunc (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tbranchName, err := as.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn work, err\n\t}\n\treturn nil, as.branches[branchName].SendAsync(work)\n}\n\nfunc AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n\treturn func(as *asyncSwitchOperator) {\n\t\tas.branches[name] = branch\n\t}\n}\n","originalFilePath":"async-switch-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,42 +1,43 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- * @author Maxim Geraskin\r\n- *\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type asyncSwitchOperator struct {\r\n-\tswitchLogic ISwitch\r\n-\tbranches    map[string]IAsyncPipeline\r\n-\tAsyncNOOP\r\n-}\r\n-\r\n-func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\r\n-\tres := \u0026asyncSwitchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]IAsyncPipeline)}\r\n-\tfirstBranch(res)\r\n-\tfor _, branch := range otherBranches {\r\n-\t\tbranch(res)\r\n-\t}\r\n-\treturn res\r\n-}\r\n-\r\n-type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\r\n-\r\n-func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tbranchName, err := as.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn work, err\r\n-\t}\r\n-\treturn nil, as.branches[branchName].SendAsync(work)\r\n-}\r\n-\r\n-func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\r\n-\treturn func(as *asyncSwitchOperator) {\r\n-\t\tas.branches[name] = branch\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ * @author Maxim Geraskin\n+ *\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type asyncSwitchOperator struct {\n+\tswitchLogic ISwitch\n+\tbranches    map[string]IAsyncPipeline\n+\tAsyncNOOP\n+}\n+\n+func AsyncSwitchOperator(switchLogic ISwitch, firstBranch AsyncSwitchOperatorOptionFunc, otherBranches ...AsyncSwitchOperatorOptionFunc) IAsyncOperator {\n+\tres := \u0026asyncSwitchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]IAsyncPipeline)}\n+\tfirstBranch(res)\n+\tfor _, branch := range otherBranches {\n+\t\t_, _ = branch, res\n+\n+\t}\n+\treturn res\n+}\n+\n+type AsyncSwitchOperatorOptionFunc func(*asyncSwitchOperator)\n+\n+func (as *asyncSwitchOperator) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tbranchName, err := as.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn work, err\n+\t}\n+\treturn nil, as.branches[branchName].SendAsync(work)\n+}\n+\n+func AsyncSwitchBranch(name string, branch IAsyncPipeline) AsyncSwitchOperatorOptionFunc {\n+\treturn func(as *asyncSwitchOperator) {\n+\t\tas.branches[name] = branch\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async-switch-impl.go.3\" with checksum 268a2b61632494638a94a3f5be5a579b\n"},{"mutator":{"mutatorName":"branch/else","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\t_, _, _, _ = outWork, wo.Stdout, outWork, flushTimer.reset\n\t\t\t}\n\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\t_, _, _, _ = outWork, wo.Stdout, outWork, flushTimer.reset\n+\t\t\t}\n+\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.0\" with checksum 422e885d5a286131ea453aaadff36e8b\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.1\" with checksum 511b0f9d81ddc99ba8df40b761b328b8\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\t_ = workpiece\n\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\t_ = workpiece\n+\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.2\" with checksum e715627a36366fc53ee94be98dcac0f3\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.3\" with checksum dd3588c5964f6c5d35fbc223db695dcf\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\t_, _ = wo.Stdout, err\n\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\t_, _ = wo.Stdout, err\n+\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.4\" with checksum e8d2581546da9e52093150d82a69b37b\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\t_, _ = wo.Stdout, err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\t_, _ = wo.Stdout, err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.5\" with checksum 3f85eacf3d11a838c14b6a14d79a0977\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\t_, _ = wo.Stdout, outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\t_, _ = wo.Stdout, outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.6\" with checksum b12c35868af6a0edd4fc0971d42631ef\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\t_, _ = wo.Stdout, work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\t_, _ = wo.Stdout, work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.8\" with checksum 151c39beeb611a83e8e5c82bc0833e0d\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\t_, _, _, _, _ = wo.isActive,\n\t\t\two.Stdout, wo.NewError, err, place\n\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\t_, _, _, _, _ = wo.isActive,\n+\t\t\two.Stdout, wo.NewError, err, place\n+\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.9\" with checksum 06bbbef438c14c9c14e8913497fd9499\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\t_, _, _, _ = wo.Stdout, wo.NewError, err, place\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\t_, _, _, _ = wo.Stdout, wo.NewError, err, place\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.10\" with checksum edcf05b097ac8efd4eb6762d4c87a707\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\t_ = w.Release\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\t_ = w.Release\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.11\" with checksum ffff605d78ad917865adea8262c9a62b\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\t_, _, _ = t.timer.Stop,\n\t\t\tt.timer.C,\n\n\t\t\tt.active\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\t_, _, _ = t.timer.Stop,\n+\t\t\tt.timer.C,\n+\n+\t\t\tt.active\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.12\" with checksum ebde3cfdb59f4ca5f85e51b863e39cfc\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\t_, _, _ = t.timer.Reset, t.intvl,\n\t\t\tt.active\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\t_, _, _ = t.timer.Reset, t.intvl,\n+\t\t\tt.active\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.14\" with checksum 3e7baa45455df469e9b3283d318f0873\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e= 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e= 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.15\" with checksum 8accd407ab849981f5008982399506c7\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 true {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 true {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.17\" with checksum f9520bc534c9aab8350b657c4dd3a515\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e -1 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e -1 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.22\" with checksum 458f7af98fff3106eed8ee4b2e80fb6d\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\t_, _ = wo, placeFlushDisassembling\n\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\t_, _ = wo, placeFlushDisassembling\n+\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.24\" with checksum 919fc391ffa38537281aac015b4448b4\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\t_ = wo.Operator.Close\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\t_ = wo.Operator.Close\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.25\" with checksum 6e61dbeb725e7965e9c89306d03c9337\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\t_ = wo.Stdout\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\t_ = wo.Stdout\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.26\" with checksum c2d0c353fb6e9b51ed35d0e74cafef24\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\t_ = workpiece\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,118 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\t_ = workpiece\n+\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.28\" with checksum 1e338e4b18da2c32f141fb5f03e4966e\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\t_ = flushTimer.reset\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\t_ = flushTimer.reset\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.29\" with checksum b695de19cf9bd1341488052a5d60ef34\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\t_ = flush.stop\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\t_ = flush.stop\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.31\" with checksum 00e3b52b4ab38f567db4b607399c3664\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\t_ = t.active\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\t_ = t.active\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.32\" with checksum 70ae1aa990f04f1945d2738db226b4c2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\t_, _ = t.timer.Reset, t.intvl\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\tt.active = false\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\t_, _ = t.timer.Reset, t.intvl\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\tt.active = false\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.34\" with checksum c4c69b6893f3b6b35166f35c4f9cf4ff\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"time\"\r\n\r\nfunc puller_async(wo *WiredOperator) {\r\n\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n\tvar open = true\r\n\tvar work interface{}\r\n\tfor open {\r\n\t\tselect {\r\n\t\tcase work, open = \u003c-wo.Stdin:\r\n\r\n\t\t\tif !open {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tworkpiece := work.(IWorkpiece)\r\n\r\n\t\t\tif !wo.isActive() {\r\n\t\t\t\tp_release(workpiece)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tstate, err := wo.prepare(work)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n\t\t\tif err != nil {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t} else {\r\n\t\t\t\tif outWork != nil {\r\n\t\t\t\t\two.Stdout \u003c- outWork\r\n\t\t\t\t}\r\n\t\t\t\tflushTimer.reset()\r\n\t\t\t}\r\n\t\tcase \u003c-flushTimer.timer.C:\r\n\t\t\tflushTimer.ticked()\r\n\t\t\tp_flush(wo, placeFlushByTimer)\r\n\t\t}\r\n\t}\r\n\r\n\tp_flush(wo, placeFlushDisassembling)\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n\tflushTimer.stop()\r\n}\r\n\r\nfunc p_flush(wo *WiredOperator, place string) {\r\n\tif !wo.isActive() {\r\n\t\treturn\r\n\t}\r\n\r\n\tflushProc := func(work IWorkpiece) {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\r\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n\t\tif wo.isActive() {\r\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc p_release(w IWorkpiece) {\r\n\tif w != nil {\r\n\t\tw.Release()\r\n\t}\r\n}\r\n\r\ntype flushTimer struct {\r\n\ttimer  *time.Timer\r\n\tintvl  time.Duration\r\n\tactive bool\r\n}\r\n\r\nfunc newFlushTimer(interval time.Duration) *flushTimer {\r\n\tflush := flushTimer{\r\n\t\tintvl:  interval,\r\n\t\tactive: true,\r\n\t\ttimer:  time.NewTimer(interval),\r\n\t}\r\n\tflush.stop()\r\n\treturn \u0026flush\r\n}\r\n\r\nfunc (t *flushTimer) stop() {\r\n\tif t.active {\r\n\t\tif !t.timer.Stop() {\r\n\t\t\t\u003c-t.timer.C\r\n\t\t}\r\n\t\tt.active = false\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) reset() {\r\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n\t\tt.timer.Reset(t.intvl)\r\n\t\tt.active = true\r\n\t}\r\n}\r\n\r\nfunc (t *flushTimer) ticked() {\r\n\tt.active = false\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport \"time\"\n\nfunc puller_async(wo *WiredOperator) {\n\tflushTimer := newFlushTimer(wo.FlushInterval)\n\tvar open = true\n\tvar work interface{}\n\tfor open {\n\t\tselect {\n\t\tcase work, open = \u003c-wo.Stdin:\n\n\t\t\tif !open {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tworkpiece := work.(IWorkpiece)\n\n\t\t\tif !wo.isActive() {\n\t\t\t\tp_release(workpiece)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tstate, err := wo.prepare(work)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\toutWork, err := wo.doAsync(workpiece, state)\n\t\t\tif err != nil {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t} else {\n\t\t\t\tif outWork != nil {\n\t\t\t\t\two.Stdout \u003c- outWork\n\t\t\t\t}\n\t\t\t\tflushTimer.reset()\n\t\t\t}\n\t\tcase \u003c-flushTimer.timer.C:\n\t\t\tflushTimer.ticked()\n\t\t\tp_flush(wo, placeFlushByTimer)\n\t\t}\n\t}\n\n\tp_flush(wo, placeFlushDisassembling)\n\two.Operator.Close()\n\tclose(wo.Stdout)\n\tflushTimer.stop()\n}\n\nfunc p_flush(wo *WiredOperator, place string) {\n\tif !wo.isActive() {\n\t\treturn\n\t}\n\n\tflushProc := func(work IWorkpiece) {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n\t\tif wo.isActive() {\n\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n\t\t}\n\t}\n}\n\nfunc p_release(w IWorkpiece) {\n\tif w != nil {\n\t\tw.Release()\n\t}\n}\n\ntype flushTimer struct {\n\ttimer  *time.Timer\n\tintvl  time.Duration\n\tactive bool\n}\n\nfunc newFlushTimer(interval time.Duration) *flushTimer {\n\tflush := flushTimer{\n\t\tintvl:  interval,\n\t\tactive: true,\n\t\ttimer:  time.NewTimer(interval),\n\t}\n\tflush.stop()\n\treturn \u0026flush\n}\n\nfunc (t *flushTimer) stop() {\n\tif t.active {\n\t\tif !t.timer.Stop() {\n\t\t\t\u003c-t.timer.C\n\t\t}\n\t\tt.active = false\n\t}\n}\n\nfunc (t *flushTimer) reset() {\n\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n\t\tt.timer.Reset(t.intvl)\n\t\tt.active = true\n\t}\n}\n\nfunc (t *flushTimer) ticked() {\n\t_ = t.active\n}\n","originalFilePath":"async.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,117 +1,117 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"time\"\r\n-\r\n-func puller_async(wo *WiredOperator) {\r\n-\tflushTimer := newFlushTimer(wo.FlushInterval)\r\n-\tvar open = true\r\n-\tvar work interface{}\r\n-\tfor open {\r\n-\t\tselect {\r\n-\t\tcase work, open = \u003c-wo.Stdin:\r\n-\r\n-\t\t\tif !open {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tworkpiece := work.(IWorkpiece)\r\n-\r\n-\t\t\tif !wo.isActive() {\r\n-\t\t\t\tp_release(workpiece)\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tif wo.forwardIfErrorAsync(workpiece) {\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\tstate, err := wo.prepare(work)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\r\n-\t\t\toutWork, err := wo.doAsync(workpiece, state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t} else {\r\n-\t\t\t\tif outWork != nil {\r\n-\t\t\t\t\two.Stdout \u003c- outWork\r\n-\t\t\t\t}\r\n-\t\t\t\tflushTimer.reset()\r\n-\t\t\t}\r\n-\t\tcase \u003c-flushTimer.timer.C:\r\n-\t\t\tflushTimer.ticked()\r\n-\t\t\tp_flush(wo, placeFlushByTimer)\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tp_flush(wo, placeFlushDisassembling)\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-\tflushTimer.stop()\r\n-}\r\n-\r\n-func p_flush(wo *WiredOperator, place string) {\r\n-\tif !wo.isActive() {\r\n-\t\treturn\r\n-\t}\r\n-\r\n-\tflushProc := func(work IWorkpiece) {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\r\n-\t\tif wo.isActive() {\r\n-\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-func p_release(w IWorkpiece) {\r\n-\tif w != nil {\r\n-\t\tw.Release()\r\n-\t}\r\n-}\r\n-\r\n-type flushTimer struct {\r\n-\ttimer  *time.Timer\r\n-\tintvl  time.Duration\r\n-\tactive bool\r\n-}\r\n-\r\n-func newFlushTimer(interval time.Duration) *flushTimer {\r\n-\tflush := flushTimer{\r\n-\t\tintvl:  interval,\r\n-\t\tactive: true,\r\n-\t\ttimer:  time.NewTimer(interval),\r\n-\t}\r\n-\tflush.stop()\r\n-\treturn \u0026flush\r\n-}\r\n-\r\n-func (t *flushTimer) stop() {\r\n-\tif t.active {\r\n-\t\tif !t.timer.Stop() {\r\n-\t\t\t\u003c-t.timer.C\r\n-\t\t}\r\n-\t\tt.active = false\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) reset() {\r\n-\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\r\n-\t\tt.timer.Reset(t.intvl)\r\n-\t\tt.active = true\r\n-\t}\r\n-}\r\n-\r\n-func (t *flushTimer) ticked() {\r\n-\tt.active = false\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import \"time\"\n+\n+func puller_async(wo *WiredOperator) {\n+\tflushTimer := newFlushTimer(wo.FlushInterval)\n+\tvar open = true\n+\tvar work interface{}\n+\tfor open {\n+\t\tselect {\n+\t\tcase work, open = \u003c-wo.Stdin:\n+\n+\t\t\tif !open {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tworkpiece := work.(IWorkpiece)\n+\n+\t\t\tif !wo.isActive() {\n+\t\t\t\tp_release(workpiece)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif wo.forwardIfErrorAsync(workpiece) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tstate, err := wo.prepare(work)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\toutWork, err := wo.doAsync(workpiece, state)\n+\t\t\tif err != nil {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t} else {\n+\t\t\t\tif outWork != nil {\n+\t\t\t\t\two.Stdout \u003c- outWork\n+\t\t\t\t}\n+\t\t\t\tflushTimer.reset()\n+\t\t\t}\n+\t\tcase \u003c-flushTimer.timer.C:\n+\t\t\tflushTimer.ticked()\n+\t\t\tp_flush(wo, placeFlushByTimer)\n+\t\t}\n+\t}\n+\n+\tp_flush(wo, placeFlushDisassembling)\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+\tflushTimer.stop()\n+}\n+\n+func p_flush(wo *WiredOperator, place string) {\n+\tif !wo.isActive() {\n+\t\treturn\n+\t}\n+\n+\tflushProc := func(work IWorkpiece) {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\tif err := wo.Operator.(IAsyncOperator).Flush(flushProc); err != nil {\n+\t\tif wo.isActive() {\n+\t\t\two.Stdout \u003c- wo.NewError(err, nil, place)\n+\t\t}\n+\t}\n+}\n+\n+func p_release(w IWorkpiece) {\n+\tif w != nil {\n+\t\tw.Release()\n+\t}\n+}\n+\n+type flushTimer struct {\n+\ttimer  *time.Timer\n+\tintvl  time.Duration\n+\tactive bool\n+}\n+\n+func newFlushTimer(interval time.Duration) *flushTimer {\n+\tflush := flushTimer{\n+\t\tintvl:  interval,\n+\t\tactive: true,\n+\t\ttimer:  time.NewTimer(interval),\n+\t}\n+\tflush.stop()\n+\treturn \u0026flush\n+}\n+\n+func (t *flushTimer) stop() {\n+\tif t.active {\n+\t\tif !t.timer.Stop() {\n+\t\t\t\u003c-t.timer.C\n+\t\t}\n+\t\tt.active = false\n+\t}\n+}\n+\n+func (t *flushTimer) reset() {\n+\tif !t.active \u0026\u0026 t.intvl \u003e 0 {\n+\t\tt.timer.Reset(t.intvl)\n+\t\tt.active = true\n+\t}\n+}\n+\n+func (t *flushTimer) ticked() {\n+\t_ = t.active\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/async.go.36\" with checksum 02a51aa183caa8b0251fc5c3890deeec\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 3\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 0\n\tqsiMustNotExist = 0\n\tqsiCanExist     = 2\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 3\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 0\n+\tqsiMustNotExist = 0\n+\tqsiCanExist     = 2\n+)\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.2\" with checksum 3d86996d5cc9741857ba47516f8a56d6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 4\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 0\n\tqsiMustNotExist = 1\n\tqsiCanExist     = 2\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 4\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 0\n+\tqsiMustNotExist = 1\n+\tqsiCanExist     = 2\n+)\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.4\" with checksum d6bb0d0b9e48ce7464bcf993605dc23c\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\n// Error places\r\nconst (\r\n\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n\tplaceFlushByTimer         = \"flush-timer\"\r\n\tplaceCatchOnErr           = \"catch-onErr\"\r\n\tplacePrepare              = \"prepare\"\r\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n\tplaceDoSync               = \"doSync\"\r\n)\r\n\r\n// QueryState\r\nconst (\r\n\tDefaultMaxPrepareQueries = 3\r\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n\titemNotExists            = \"item with alias %s not exists\"\r\n\titemExists               = \"item with key %+v exists\"\r\n)\r\n\r\n// queryStateItem.kind\r\nconst (\r\n\tqsiMustExist    = 0\r\n\tqsiMustNotExist = 1\r\n\tqsiCanExist     = 2\r\n)\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\n// Error places\nconst (\n\tplaceFlushDisassembling   = \"flush-disassembling\"\n\tplaceFlushByTimer         = \"flush-timer\"\n\tplaceCatchOnErr           = \"catch-onErr\"\n\tplacePrepare              = \"prepare\"\n\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n\tplaceDoSync               = \"doSync\"\n)\n\n// QueryState\nconst (\n\tDefaultMaxPrepareQueries = 3\n\tqueryStateQuotaExceed    = \"query state quota exceed\"\n\titemNotExists            = \"item with alias %s not exists\"\n\titemExists               = \"item with key %+v exists\"\n)\n\n// queryStateItem.kind\nconst (\n\tqsiMustExist    = 1\n\tqsiMustNotExist = 1\n\tqsiCanExist     = 2\n)\n","originalFilePath":"consts.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,35 +1,35 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-// Error places\r\n-const (\r\n-\tplaceFlushDisassembling   = \"flush-disassembling\"\r\n-\tplaceFlushByTimer         = \"flush-timer\"\r\n-\tplaceCatchOnErr           = \"catch-onErr\"\r\n-\tplacePrepare              = \"prepare\"\r\n-\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\r\n-\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\r\n-\tplaceDoSync               = \"doSync\"\r\n-)\r\n-\r\n-// QueryState\r\n-const (\r\n-\tDefaultMaxPrepareQueries = 3\r\n-\tqueryStateQuotaExceed    = \"query state quota exceed\"\r\n-\titemNotExists            = \"item with alias %s not exists\"\r\n-\titemExists               = \"item with key %+v exists\"\r\n-)\r\n-\r\n-// queryStateItem.kind\r\n-const (\r\n-\tqsiMustExist    = 0\r\n-\tqsiMustNotExist = 1\r\n-\tqsiCanExist     = 2\r\n-)\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+// Error places\n+const (\n+\tplaceFlushDisassembling   = \"flush-disassembling\"\n+\tplaceFlushByTimer         = \"flush-timer\"\n+\tplaceCatchOnErr           = \"catch-onErr\"\n+\tplacePrepare              = \"prepare\"\n+\tplaceDoAsyncOutWorkIsNil  = \"doAsync, outWork==nil\"\n+\tplaceDoAsyncOutWorkNotNil = \"doAsync, outWork!=nil\"\n+\tplaceDoSync               = \"doSync\"\n+)\n+\n+// QueryState\n+const (\n+\tDefaultMaxPrepareQueries = 3\n+\tqueryStateQuotaExceed    = \"query state quota exceed\"\n+\titemNotExists            = \"item with alias %s not exists\"\n+\titemExists               = \"item with key %+v exists\"\n+)\n+\n+// queryStateItem.kind\n+const (\n+\tqsiMustExist    = 1\n+\tqsiMustNotExist = 1\n+\tqsiCanExist     = 2\n+)\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/consts.go.5\" with checksum 8021c436f971878cf5550d22f2101b51\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"strings\"\r\n)\r\n\r\ntype IErrorPipeline interface {\r\n\terror\r\n\tIWorkpiece\r\n\tGetWork() interface{}\r\n}\r\n\r\ntype errPipeline struct {\r\n\terr  error\r\n\twork interface{}\r\n}\r\n\r\nfunc (e errPipeline) Release() {\r\n}\r\n\r\nfunc (e errPipeline) Error() string {\r\n\treturn e.err.Error()\r\n}\r\n\r\nfunc (e errPipeline) Unwrap() error {\r\n\treturn e.err\r\n}\r\n\r\nfunc (e errPipeline) GetWork() interface{} {\r\n\treturn e.work\r\n}\r\n\r\ntype ErrInBranches struct {\r\n\tErrors []error\r\n}\r\n\r\nfunc (e ErrInBranches) Error() string {\r\n\tss := make([]string, len(e.Errors))\r\n\tfor i, err := range e.Errors {\r\n\t\tss[i] = err.Error()\r\n\t}\r\n\treturn strings.Join(ss, \",\")\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"strings\"\n)\n\ntype IErrorPipeline interface {\n\terror\n\tIWorkpiece\n\tGetWork() interface{}\n}\n\ntype errPipeline struct {\n\terr  error\n\twork interface{}\n}\n\nfunc (e errPipeline) Release() {\n}\n\nfunc (e errPipeline) Error() string {\n\treturn e.err.Error()\n}\n\nfunc (e errPipeline) Unwrap() error {\n\treturn e.err\n}\n\nfunc (e errPipeline) GetWork() interface{} {\n\treturn e.work\n}\n\ntype ErrInBranches struct {\n\tErrors []error\n}\n\nfunc (e ErrInBranches) Error() string {\n\tss := make([]string, len(e.Errors))\n\tfor i, err := range e.Errors {\n\t\tbreak\n\t\tss[i] = err.Error()\n\t}\n\n\treturn strings.Join(ss, \",\")\n}\n","originalFilePath":"errors.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,51 +1,53 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type IErrorPipeline interface {\r\n-\terror\r\n-\tIWorkpiece\r\n-\tGetWork() interface{}\r\n-}\r\n-\r\n-type errPipeline struct {\r\n-\terr  error\r\n-\twork interface{}\r\n-}\r\n-\r\n-func (e errPipeline) Release() {\r\n-}\r\n-\r\n-func (e errPipeline) Error() string {\r\n-\treturn e.err.Error()\r\n-}\r\n-\r\n-func (e errPipeline) Unwrap() error {\r\n-\treturn e.err\r\n-}\r\n-\r\n-func (e errPipeline) GetWork() interface{} {\r\n-\treturn e.work\r\n-}\r\n-\r\n-type ErrInBranches struct {\r\n-\tErrors []error\r\n-}\r\n-\r\n-func (e ErrInBranches) Error() string {\r\n-\tss := make([]string, len(e.Errors))\r\n-\tfor i, err := range e.Errors {\r\n-\t\tss[i] = err.Error()\r\n-\t}\r\n-\treturn strings.Join(ss, \",\")\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"strings\"\n+)\n+\n+type IErrorPipeline interface {\n+\terror\n+\tIWorkpiece\n+\tGetWork() interface{}\n+}\n+\n+type errPipeline struct {\n+\terr  error\n+\twork interface{}\n+}\n+\n+func (e errPipeline) Release() {\n+}\n+\n+func (e errPipeline) Error() string {\n+\treturn e.err.Error()\n+}\n+\n+func (e errPipeline) Unwrap() error {\n+\treturn e.err\n+}\n+\n+func (e errPipeline) GetWork() interface{} {\n+\treturn e.work\n+}\n+\n+type ErrInBranches struct {\n+\tErrors []error\n+}\n+\n+func (e ErrInBranches) Error() string {\n+\tss := make([]string, len(e.Errors))\n+\tfor i, err := range e.Errors {\n+\t\tbreak\n+\t\tss[i] = err.Error()\n+\t}\n+\n+\treturn strings.Join(ss, \",\")\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/errors.go.0\" with checksum fa391295629cad847f86c4aadb79be99\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"strings\"\r\n)\r\n\r\ntype IErrorPipeline interface {\r\n\terror\r\n\tIWorkpiece\r\n\tGetWork() interface{}\r\n}\r\n\r\ntype errPipeline struct {\r\n\terr  error\r\n\twork interface{}\r\n}\r\n\r\nfunc (e errPipeline) Release() {\r\n}\r\n\r\nfunc (e errPipeline) Error() string {\r\n\treturn e.err.Error()\r\n}\r\n\r\nfunc (e errPipeline) Unwrap() error {\r\n\treturn e.err\r\n}\r\n\r\nfunc (e errPipeline) GetWork() interface{} {\r\n\treturn e.work\r\n}\r\n\r\ntype ErrInBranches struct {\r\n\tErrors []error\r\n}\r\n\r\nfunc (e ErrInBranches) Error() string {\r\n\tss := make([]string, len(e.Errors))\r\n\tfor i, err := range e.Errors {\r\n\t\tss[i] = err.Error()\r\n\t}\r\n\treturn strings.Join(ss, \",\")\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"strings\"\n)\n\ntype IErrorPipeline interface {\n\terror\n\tIWorkpiece\n\tGetWork() interface{}\n}\n\ntype errPipeline struct {\n\terr  error\n\twork interface{}\n}\n\nfunc (e errPipeline) Release() {\n}\n\nfunc (e errPipeline) Error() string {\n\treturn e.err.Error()\n}\n\nfunc (e errPipeline) Unwrap() error {\n\treturn e.err\n}\n\nfunc (e errPipeline) GetWork() interface{} {\n\treturn e.work\n}\n\ntype ErrInBranches struct {\n\tErrors []error\n}\n\nfunc (e ErrInBranches) Error() string {\n\tss := make([]string, len(e.Errors))\n\tfor i, err := range e.Errors {\n\t\t_, _, _ = ss, i, err.Error\n\t}\n\treturn strings.Join(ss, \",\")\n}\n","originalFilePath":"errors.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,51 +1,51 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type IErrorPipeline interface {\r\n-\terror\r\n-\tIWorkpiece\r\n-\tGetWork() interface{}\r\n-}\r\n-\r\n-type errPipeline struct {\r\n-\terr  error\r\n-\twork interface{}\r\n-}\r\n-\r\n-func (e errPipeline) Release() {\r\n-}\r\n-\r\n-func (e errPipeline) Error() string {\r\n-\treturn e.err.Error()\r\n-}\r\n-\r\n-func (e errPipeline) Unwrap() error {\r\n-\treturn e.err\r\n-}\r\n-\r\n-func (e errPipeline) GetWork() interface{} {\r\n-\treturn e.work\r\n-}\r\n-\r\n-type ErrInBranches struct {\r\n-\tErrors []error\r\n-}\r\n-\r\n-func (e ErrInBranches) Error() string {\r\n-\tss := make([]string, len(e.Errors))\r\n-\tfor i, err := range e.Errors {\r\n-\t\tss[i] = err.Error()\r\n-\t}\r\n-\treturn strings.Join(ss, \",\")\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"strings\"\n+)\n+\n+type IErrorPipeline interface {\n+\terror\n+\tIWorkpiece\n+\tGetWork() interface{}\n+}\n+\n+type errPipeline struct {\n+\terr  error\n+\twork interface{}\n+}\n+\n+func (e errPipeline) Release() {\n+}\n+\n+func (e errPipeline) Error() string {\n+\treturn e.err.Error()\n+}\n+\n+func (e errPipeline) Unwrap() error {\n+\treturn e.err\n+}\n+\n+func (e errPipeline) GetWork() interface{} {\n+\treturn e.work\n+}\n+\n+type ErrInBranches struct {\n+\tErrors []error\n+}\n+\n+func (e ErrInBranches) Error() string {\n+\tss := make([]string, len(e.Errors))\n+\tfor i, err := range e.Errors {\n+\t\t_, _, _ = ss, i, err.Error\n+\t}\n+\treturn strings.Join(ss, \",\")\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/errors.go.1\" with checksum cf900f363b1cfb396302156d9fa8caad\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.0\" with checksum e3bed2153376ed991ff9da295ac7c62a\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.1\" with checksum 7e2a5b30f0494de92062cdd9f3f41587\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\t_, _ = errs, err\n\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\t_, _ = errs, err\n+\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.2\" with checksum 703c7fb8c4b9bafc5950589bda5e5136\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\t_, _ = errs, err\n\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\t_, _ = errs, err\n+\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.3\" with checksum fa2f3ff14359c115cacabcb828e23ea9\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.4\" with checksum 5dc365c7f761f26d941728d6d5b11401\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.5\" with checksum ebfce1d4161e17aff35eda8d2799f827\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbreak\n\t\tbranch.Close()\n\t}\n\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,97 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbreak\n+\t\tbranch.Close()\n+\t}\n+\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.6\" with checksum bafb1f111041898e53485955461cd1ba\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tbreak\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tbreak\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.7\" with checksum 5c3d3a033205606a0009ed43dbacafa6\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\tbreak\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\tbreak\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.8\" with checksum abb03358d5c9759e24c1982191d195b2\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\tbreak\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\tbreak\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.9\" with checksum 95ef48f19e8b572fdb74e0f9ec68c2c8\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbreak\n\t\tbranch(forkOperator)\n\t}\n\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,97 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbreak\n+\t\tbranch(forkOperator)\n+\t}\n+\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.10\" with checksum 73b37d663ea9f1ba1e1671aa20d55cc5\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(0)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(0)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.11\" with checksum 682c62a12db94c671c9e94acd8b56d63\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == -1 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == -1 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.12\" with checksum 6b6ec38c105f94fee66b992f903b9c4b\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(2)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(2)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.13\" with checksum 1e8a504b2ff4ed4f90f11c658176198d\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 1 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 1 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.14\" with checksum 19391b0ae791636069ba96778a4cec1f\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\t_ = branch.Close\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\t_ = branch.Close\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.15\" with checksum bd26f9a3e7cce5691d78e8830ac55f0e\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\t_ = wg.Wait\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,94 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\t_ = wg.Wait\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.16\" with checksum de90b1ee003eab4c66fa57a6120b839c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\t_ = errs\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\t_ = errs\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.17\" with checksum 086a23e31f3905b2a1e836eacf1fa2c0\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\t_, _, _ = forks, i, fork\n\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\t_, _, _ = forks, i, fork\n+\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.18\" with checksum 7964de23b2aab99173e131cfbbbbb7c9\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\t_ = wg.Add\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\t_ = wg.Add\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.20\" with checksum 3ea4f60d26cfdb0a1200a463b0313fb2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, _, _, _, _, _ = err, branch.DoSync, ctx, forks, i, state\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t_, _, _, _, _, _ = err, branch.DoSync, ctx, forks, i, state\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.21\" with checksum 66e153e7012ae1a6288b94a2cdb7459d\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\t_, _, _ = errInBranches.Errors, errInBranches.Errors, e\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\t_, _, _ = errInBranches.Errors, errInBranches.Errors, e\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.22\" with checksum 42318e68ae14b1513b803ea16a3f2c4b\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\t_, _ = forkOperator.fork, fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,95 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\t_, _ = forkOperator.fork, fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.23\" with checksum 648c2e3113b144f4a6216177824f6f58\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\t_, _ = branch, forkOperator\n\n\tfor _, branch := range branches {\n\t\tbranch(forkOperator)\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\t_, _ = branch, forkOperator\n+\n+\tfor _, branch := range branches {\n+\t\tbranch(forkOperator)\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.24\" with checksum fef19cce36f1dc5ae3d648950b8474b2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"sync\"\r\n)\r\n\r\ntype forkOperator struct {\r\n\tfork     Fork\r\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n}\r\n\r\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (f forkOperator) Close() {\r\n\tfor _, branch := range f.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tforks := make([]interface{}, len(f.branches))\r\n\tfor i := range f.branches {\r\n\t\tfork, err := f.fork(work, i)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif fork == nil {\r\n\t\t\tpanic(\"fork is nil\")\r\n\t\t}\r\n\t\tforks[i] = fork\r\n\t}\r\n\r\n\twg := sync.WaitGroup{}\r\n\terrs := make(chan error, len(f.branches))\r\n\r\n\tfor i, branch := range f.branches {\r\n\t\twg.Add(1)\r\n\t\tgo func(i int, branch ISyncOperator) {\r\n\t\t\tdefer wg.Done()\r\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrs \u003c- err\r\n\t\t\t}\r\n\t\t}(i, branch)\r\n\t}\r\n\r\n\twg.Wait()\r\n\tclose(errs)\r\n\r\n\tif len(errs) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrInBranches := ErrInBranches{}\r\n\tfor e := range errs {\r\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n\t}\r\n\r\n\treturn errInBranches\r\n}\r\n\r\ntype ForkOperatorOptionFunc func(*forkOperator)\r\n\r\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n\tif fork == nil {\r\n\t\tpanic(\"fork must be not nil\")\r\n\t}\r\n\tforkOperator := new(forkOperator)\r\n\tforkOperator.fork = fork\r\n\tbranch(forkOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(forkOperator)\r\n\t}\r\n\treturn forkOperator\r\n}\r\n\r\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n\treturn func(forkOperator *forkOperator) {\r\n\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype forkOperator struct {\n\tfork     Fork\n\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n}\n\nfunc (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (f forkOperator) Close() {\n\tfor _, branch := range f.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tforks := make([]interface{}, len(f.branches))\n\tfor i := range f.branches {\n\t\tfork, err := f.fork(work, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fork == nil {\n\t\t\tpanic(\"fork is nil\")\n\t\t}\n\t\tforks[i] = fork\n\t}\n\n\twg := sync.WaitGroup{}\n\terrs := make(chan error, len(f.branches))\n\n\tfor i, branch := range f.branches {\n\t\twg.Add(1)\n\t\tgo func(i int, branch ISyncOperator) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = branch.DoSync(ctx, forks[i], state)\n\t\t\tif err != nil {\n\t\t\t\terrs \u003c- err\n\t\t\t}\n\t\t}(i, branch)\n\t}\n\n\twg.Wait()\n\tclose(errs)\n\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\n\terrInBranches := ErrInBranches{}\n\tfor e := range errs {\n\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n\t}\n\n\treturn errInBranches\n}\n\ntype ForkOperatorOptionFunc func(*forkOperator)\n\nfunc ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n\tif fork == nil {\n\t\tpanic(\"fork must be not nil\")\n\t}\n\tforkOperator := new(forkOperator)\n\tforkOperator.fork = fork\n\tbranch(forkOperator)\n\tfor _, branch := range branches {\n\t\t_, _ = branch, forkOperator\n\n\t}\n\treturn forkOperator\n}\n\nfunc ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n\treturn func(forkOperator *forkOperator) {\n\t\tforkOperator.branches = append(forkOperator.branches, o)\n\t}\n}\n","originalFilePath":"fork-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,95 +1,96 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"sync\"\r\n-)\r\n-\r\n-type forkOperator struct {\r\n-\tfork     Fork\r\n-\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\r\n-}\r\n-\r\n-func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (f forkOperator) Close() {\r\n-\tfor _, branch := range f.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tforks := make([]interface{}, len(f.branches))\r\n-\tfor i := range f.branches {\r\n-\t\tfork, err := f.fork(work, i)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif fork == nil {\r\n-\t\t\tpanic(\"fork is nil\")\r\n-\t\t}\r\n-\t\tforks[i] = fork\r\n-\t}\r\n-\r\n-\twg := sync.WaitGroup{}\r\n-\terrs := make(chan error, len(f.branches))\r\n-\r\n-\tfor i, branch := range f.branches {\r\n-\t\twg.Add(1)\r\n-\t\tgo func(i int, branch ISyncOperator) {\r\n-\t\t\tdefer wg.Done()\r\n-\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t\treturn\r\n-\t\t\t}\r\n-\t\t\terr = branch.DoSync(ctx, forks[i], state)\r\n-\t\t\tif err != nil {\r\n-\t\t\t\terrs \u003c- err\r\n-\t\t\t}\r\n-\t\t}(i, branch)\r\n-\t}\r\n-\r\n-\twg.Wait()\r\n-\tclose(errs)\r\n-\r\n-\tif len(errs) == 0 {\r\n-\t\treturn nil\r\n-\t}\r\n-\r\n-\terrInBranches := ErrInBranches{}\r\n-\tfor e := range errs {\r\n-\t\terrInBranches.Errors = append(errInBranches.Errors, e)\r\n-\t}\r\n-\r\n-\treturn errInBranches\r\n-}\r\n-\r\n-type ForkOperatorOptionFunc func(*forkOperator)\r\n-\r\n-func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\r\n-\tif fork == nil {\r\n-\t\tpanic(\"fork must be not nil\")\r\n-\t}\r\n-\tforkOperator := new(forkOperator)\r\n-\tforkOperator.fork = fork\r\n-\tbranch(forkOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(forkOperator)\r\n-\t}\r\n-\treturn forkOperator\r\n-}\r\n-\r\n-func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\r\n-\treturn func(forkOperator *forkOperator) {\r\n-\t\tforkOperator.branches = append(forkOperator.branches, o)\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+)\n+\n+type forkOperator struct {\n+\tfork     Fork\n+\tbranches []ISyncOperator // note: OpFuncQueryState returned by branch.Prepare() will be ignored\n+}\n+\n+func (f forkOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (f forkOperator) Close() {\n+\tfor _, branch := range f.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (f forkOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tforks := make([]interface{}, len(f.branches))\n+\tfor i := range f.branches {\n+\t\tfork, err := f.fork(work, i)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif fork == nil {\n+\t\t\tpanic(\"fork is nil\")\n+\t\t}\n+\t\tforks[i] = fork\n+\t}\n+\n+\twg := sync.WaitGroup{}\n+\terrs := make(chan error, len(f.branches))\n+\n+\tfor i, branch := range f.branches {\n+\t\twg.Add(1)\n+\t\tgo func(i int, branch ISyncOperator) {\n+\t\t\tdefer wg.Done()\n+\t\t\t_, err := branch.Prepare(work) // OpFuncQueryState in branches is senceless\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = branch.DoSync(ctx, forks[i], state)\n+\t\t\tif err != nil {\n+\t\t\t\terrs \u003c- err\n+\t\t\t}\n+\t\t}(i, branch)\n+\t}\n+\n+\twg.Wait()\n+\tclose(errs)\n+\n+\tif len(errs) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\terrInBranches := ErrInBranches{}\n+\tfor e := range errs {\n+\t\terrInBranches.Errors = append(errInBranches.Errors, e)\n+\t}\n+\n+\treturn errInBranches\n+}\n+\n+type ForkOperatorOptionFunc func(*forkOperator)\n+\n+func ForkOperator(fork Fork, branch ForkOperatorOptionFunc, branches ...ForkOperatorOptionFunc) ISyncOperator {\n+\tif fork == nil {\n+\t\tpanic(\"fork must be not nil\")\n+\t}\n+\tforkOperator := new(forkOperator)\n+\tforkOperator.fork = fork\n+\tbranch(forkOperator)\n+\tfor _, branch := range branches {\n+\t\t_, _ = branch, forkOperator\n+\n+\t}\n+\treturn forkOperator\n+}\n+\n+func ForkBranch(o ISyncOperator) ForkOperatorOptionFunc {\n+\treturn func(forkOperator *forkOperator) {\n+\t\tforkOperator.branches = append(forkOperator.branches, o)\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/fork-operator-impl.go.26\" with checksum 07e8440b90a9fd47c17d4ae9ba903d2e\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\ntype queryStateItem struct {\r\n\tkind      int\r\n\talias     string\r\n\tstorageID StorageID\r\n\tstorage   IStorage\r\n\tkey       interface{}\r\n\tvalue     IRawValue\r\n}\r\n\r\ntype updateIntent struct {\r\n\talias string\r\n\tfupd  OpFuncUpdate\r\n}\r\n\r\ntype createIntent struct {\r\n\tstorageID StorageID\r\n\tkey       interface{}\r\n\tfnew      OpFuncNew\r\n}\r\n\r\nfunc pipelinePanic(msg string, operatorName string, context IWorkpieceContext) {\r\n\tpanic(fmt.Sprintf(\"critical error in operator '%s': %s. Pipeline '%s' [%s]\", operatorName, msg, context.GetPipelineName(), context.GetPipelineStruct()))\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\ntype queryStateItem struct {\n\tkind      int\n\talias     string\n\tstorageID StorageID\n\tstorage   IStorage\n\tkey       interface{}\n\tvalue     IRawValue\n}\n\ntype updateIntent struct {\n\talias string\n\tfupd  OpFuncUpdate\n}\n\ntype createIntent struct {\n\tstorageID StorageID\n\tkey       interface{}\n\tfnew      OpFuncNew\n}\n\nfunc pipelinePanic(msg string, operatorName string, context IWorkpieceContext) {\n\t_, _, _, _, _ = fmt.Sprintf, operatorName, msg, context.GetPipelineName, context.GetPipelineStruct\n}\n","originalFilePath":"impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,37 +1,37 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-type queryStateItem struct {\r\n-\tkind      int\r\n-\talias     string\r\n-\tstorageID StorageID\r\n-\tstorage   IStorage\r\n-\tkey       interface{}\r\n-\tvalue     IRawValue\r\n-}\r\n-\r\n-type updateIntent struct {\r\n-\talias string\r\n-\tfupd  OpFuncUpdate\r\n-}\r\n-\r\n-type createIntent struct {\r\n-\tstorageID StorageID\r\n-\tkey       interface{}\r\n-\tfnew      OpFuncNew\r\n-}\r\n-\r\n-func pipelinePanic(msg string, operatorName string, context IWorkpieceContext) {\r\n-\tpanic(fmt.Sprintf(\"critical error in operator '%s': %s. Pipeline '%s' [%s]\", operatorName, msg, context.GetPipelineName(), context.GetPipelineStruct()))\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+type queryStateItem struct {\n+\tkind      int\n+\talias     string\n+\tstorageID StorageID\n+\tstorage   IStorage\n+\tkey       interface{}\n+\tvalue     IRawValue\n+}\n+\n+type updateIntent struct {\n+\talias string\n+\tfupd  OpFuncUpdate\n+}\n+\n+type createIntent struct {\n+\tstorageID StorageID\n+\tkey       interface{}\n+\tfnew      OpFuncNew\n+}\n+\n+func pipelinePanic(msg string, operatorName string, context IWorkpieceContext) {\n+\t_, _, _, _, _ = fmt.Sprintf, operatorName, msg, context.GetPipelineName, context.GetPipelineStruct\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/impl.go.0\" with checksum 297943154d6184890fd56277a4e7e187\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype NOOP struct{}\r\n\r\ntype AsyncNOOP struct{}\r\n\r\ntype NOPService struct{}\r\n\r\ntype implISyncOperatorSimple struct {\r\n\tNOOP\r\n\tdoSync func(ctx context.Context, work interface{}) (err error)\r\n}\r\n\r\ntype implAsyncOperatorSimple struct {\r\n\tAsyncNOOP\r\n\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\r\n}\r\n\r\ntype implIServiceSimple struct {\r\n\tNOPService\r\n\trun func(ctx context.Context)\r\n}\r\n\r\nfunc (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *NOOP) Close() {}\r\n\r\nfunc (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Close() {}\r\n\r\nfunc (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\r\n\r\nfunc (n *NOPService) Prepare(work interface{}) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *NOPService) Run(ctx context.Context) {}\r\n\r\nfunc (n *NOPService) Stop() {}\r\n\r\nfunc (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tif so.doSync != nil {\r\n\t\treturn so.doSync(ctx, work)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tif ao.doAsync != nil {\r\n\t\treturn ao.doAsync(ctx, work)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc (s *implIServiceSimple) Run(ctx context.Context) {\r\n\tif s.run != nil {\r\n\t\ts.run(ctx)\r\n\t}\r\n}\r\n\r\n// based on ISyncOperator\r\nfunc WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\r\n\treturn WireSyncOperator(name, NewSyncOp(doSync))\r\n}\r\n\r\n// based on IAsyncOperator\r\nfunc WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\r\n\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\r\n}\r\n\r\nfunc NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\r\n\treturn \u0026implISyncOperatorSimple{doSync: doSync}\r\n}\r\n\r\nfunc NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\r\n\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\r\n}\r\n\r\nfunc NewService(run func(ctx context.Context)) IService {\r\n\treturn \u0026implIServiceSimple{run: run}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype NOOP struct{}\n\ntype AsyncNOOP struct{}\n\ntype NOPService struct{}\n\ntype implISyncOperatorSimple struct {\n\tNOOP\n\tdoSync func(ctx context.Context, work interface{}) (err error)\n}\n\ntype implAsyncOperatorSimple struct {\n\tAsyncNOOP\n\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\n}\n\ntype implIServiceSimple struct {\n\tNOPService\n\trun func(ctx context.Context)\n}\n\nfunc (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn\n}\n\nfunc (n *NOOP) Close() {}\n\nfunc (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Close() {}\n\nfunc (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\n\nfunc (n *NOPService) Prepare(work interface{}) (err error) {\n\treturn\n}\n\nfunc (n *NOPService) Run(ctx context.Context) {}\n\nfunc (n *NOPService) Stop() {}\n\nfunc (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tif so.doSync != nil {\n\t\t_, _, _ = so.doSync, ctx, work\n\t}\n\treturn\n}\n\nfunc (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tif ao.doAsync != nil {\n\t\treturn ao.doAsync(ctx, work)\n\t}\n\treturn\n}\n\nfunc (s *implIServiceSimple) Run(ctx context.Context) {\n\tif s.run != nil {\n\t\ts.run(ctx)\n\t}\n}\n\n// based on ISyncOperator\nfunc WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\n\treturn WireSyncOperator(name, NewSyncOp(doSync))\n}\n\n// based on IAsyncOperator\nfunc WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\n\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\n}\n\nfunc NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\n\treturn \u0026implISyncOperatorSimple{doSync: doSync}\n}\n\nfunc NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\n\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\n}\n\nfunc NewService(run func(ctx context.Context)) IService {\n\treturn \u0026implIServiceSimple{run: run}\n}\n","originalFilePath":"noop-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,106 +1,106 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type NOOP struct{}\r\n-\r\n-type AsyncNOOP struct{}\r\n-\r\n-type NOPService struct{}\r\n-\r\n-type implISyncOperatorSimple struct {\r\n-\tNOOP\r\n-\tdoSync func(ctx context.Context, work interface{}) (err error)\r\n-}\r\n-\r\n-type implAsyncOperatorSimple struct {\r\n-\tAsyncNOOP\r\n-\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\r\n-}\r\n-\r\n-type implIServiceSimple struct {\r\n-\tNOPService\r\n-\trun func(ctx context.Context)\r\n-}\r\n-\r\n-func (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *NOOP) Close() {}\r\n-\r\n-func (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Close() {}\r\n-\r\n-func (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\r\n-\r\n-func (n *NOPService) Prepare(work interface{}) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *NOPService) Run(ctx context.Context) {}\r\n-\r\n-func (n *NOPService) Stop() {}\r\n-\r\n-func (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tif so.doSync != nil {\r\n-\t\treturn so.doSync(ctx, work)\r\n-\t}\r\n-\treturn\r\n-}\r\n-\r\n-func (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tif ao.doAsync != nil {\r\n-\t\treturn ao.doAsync(ctx, work)\r\n-\t}\r\n-\treturn\r\n-}\r\n-\r\n-func (s *implIServiceSimple) Run(ctx context.Context) {\r\n-\tif s.run != nil {\r\n-\t\ts.run(ctx)\r\n-\t}\r\n-}\r\n-\r\n-// based on ISyncOperator\r\n-func WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\r\n-\treturn WireSyncOperator(name, NewSyncOp(doSync))\r\n-}\r\n-\r\n-// based on IAsyncOperator\r\n-func WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\r\n-\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\r\n-}\r\n-\r\n-func NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\r\n-\treturn \u0026implISyncOperatorSimple{doSync: doSync}\r\n-}\r\n-\r\n-func NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\r\n-\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\r\n-}\r\n-\r\n-func NewService(run func(ctx context.Context)) IService {\r\n-\treturn \u0026implIServiceSimple{run: run}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type NOOP struct{}\n+\n+type AsyncNOOP struct{}\n+\n+type NOPService struct{}\n+\n+type implISyncOperatorSimple struct {\n+\tNOOP\n+\tdoSync func(ctx context.Context, work interface{}) (err error)\n+}\n+\n+type implAsyncOperatorSimple struct {\n+\tAsyncNOOP\n+\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\n+}\n+\n+type implIServiceSimple struct {\n+\tNOPService\n+\trun func(ctx context.Context)\n+}\n+\n+func (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn\n+}\n+\n+func (n *NOOP) Close() {}\n+\n+func (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Close() {}\n+\n+func (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\n+\n+func (n *NOPService) Prepare(work interface{}) (err error) {\n+\treturn\n+}\n+\n+func (n *NOPService) Run(ctx context.Context) {}\n+\n+func (n *NOPService) Stop() {}\n+\n+func (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tif so.doSync != nil {\n+\t\t_, _, _ = so.doSync, ctx, work\n+\t}\n+\treturn\n+}\n+\n+func (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tif ao.doAsync != nil {\n+\t\treturn ao.doAsync(ctx, work)\n+\t}\n+\treturn\n+}\n+\n+func (s *implIServiceSimple) Run(ctx context.Context) {\n+\tif s.run != nil {\n+\t\ts.run(ctx)\n+\t}\n+}\n+\n+// based on ISyncOperator\n+func WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\n+\treturn WireSyncOperator(name, NewSyncOp(doSync))\n+}\n+\n+// based on IAsyncOperator\n+func WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\n+\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\n+}\n+\n+func NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\n+\treturn \u0026implISyncOperatorSimple{doSync: doSync}\n+}\n+\n+func NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\n+\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\n+}\n+\n+func NewService(run func(ctx context.Context)) IService {\n+\treturn \u0026implIServiceSimple{run: run}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/noop-impl.go.0\" with checksum e4c7744891aedccc549089978527a062\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype NOOP struct{}\r\n\r\ntype AsyncNOOP struct{}\r\n\r\ntype NOPService struct{}\r\n\r\ntype implISyncOperatorSimple struct {\r\n\tNOOP\r\n\tdoSync func(ctx context.Context, work interface{}) (err error)\r\n}\r\n\r\ntype implAsyncOperatorSimple struct {\r\n\tAsyncNOOP\r\n\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\r\n}\r\n\r\ntype implIServiceSimple struct {\r\n\tNOPService\r\n\trun func(ctx context.Context)\r\n}\r\n\r\nfunc (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *NOOP) Close() {}\r\n\r\nfunc (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Close() {}\r\n\r\nfunc (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\r\n\r\nfunc (n *NOPService) Prepare(work interface{}) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *NOPService) Run(ctx context.Context) {}\r\n\r\nfunc (n *NOPService) Stop() {}\r\n\r\nfunc (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tif so.doSync != nil {\r\n\t\treturn so.doSync(ctx, work)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tif ao.doAsync != nil {\r\n\t\treturn ao.doAsync(ctx, work)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc (s *implIServiceSimple) Run(ctx context.Context) {\r\n\tif s.run != nil {\r\n\t\ts.run(ctx)\r\n\t}\r\n}\r\n\r\n// based on ISyncOperator\r\nfunc WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\r\n\treturn WireSyncOperator(name, NewSyncOp(doSync))\r\n}\r\n\r\n// based on IAsyncOperator\r\nfunc WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\r\n\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\r\n}\r\n\r\nfunc NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\r\n\treturn \u0026implISyncOperatorSimple{doSync: doSync}\r\n}\r\n\r\nfunc NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\r\n\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\r\n}\r\n\r\nfunc NewService(run func(ctx context.Context)) IService {\r\n\treturn \u0026implIServiceSimple{run: run}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype NOOP struct{}\n\ntype AsyncNOOP struct{}\n\ntype NOPService struct{}\n\ntype implISyncOperatorSimple struct {\n\tNOOP\n\tdoSync func(ctx context.Context, work interface{}) (err error)\n}\n\ntype implAsyncOperatorSimple struct {\n\tAsyncNOOP\n\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\n}\n\ntype implIServiceSimple struct {\n\tNOPService\n\trun func(ctx context.Context)\n}\n\nfunc (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn\n}\n\nfunc (n *NOOP) Close() {}\n\nfunc (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Close() {}\n\nfunc (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\n\nfunc (n *NOPService) Prepare(work interface{}) (err error) {\n\treturn\n}\n\nfunc (n *NOPService) Run(ctx context.Context) {}\n\nfunc (n *NOPService) Stop() {}\n\nfunc (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tif so.doSync != nil {\n\t\treturn so.doSync(ctx, work)\n\t}\n\treturn\n}\n\nfunc (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tif ao.doAsync != nil {\n\t\t_, _, _ = ao.doAsync, ctx, work\n\t}\n\treturn\n}\n\nfunc (s *implIServiceSimple) Run(ctx context.Context) {\n\tif s.run != nil {\n\t\ts.run(ctx)\n\t}\n}\n\n// based on ISyncOperator\nfunc WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\n\treturn WireSyncOperator(name, NewSyncOp(doSync))\n}\n\n// based on IAsyncOperator\nfunc WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\n\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\n}\n\nfunc NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\n\treturn \u0026implISyncOperatorSimple{doSync: doSync}\n}\n\nfunc NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\n\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\n}\n\nfunc NewService(run func(ctx context.Context)) IService {\n\treturn \u0026implIServiceSimple{run: run}\n}\n","originalFilePath":"noop-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,106 +1,106 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type NOOP struct{}\r\n-\r\n-type AsyncNOOP struct{}\r\n-\r\n-type NOPService struct{}\r\n-\r\n-type implISyncOperatorSimple struct {\r\n-\tNOOP\r\n-\tdoSync func(ctx context.Context, work interface{}) (err error)\r\n-}\r\n-\r\n-type implAsyncOperatorSimple struct {\r\n-\tAsyncNOOP\r\n-\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\r\n-}\r\n-\r\n-type implIServiceSimple struct {\r\n-\tNOPService\r\n-\trun func(ctx context.Context)\r\n-}\r\n-\r\n-func (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *NOOP) Close() {}\r\n-\r\n-func (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Close() {}\r\n-\r\n-func (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\r\n-\r\n-func (n *NOPService) Prepare(work interface{}) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *NOPService) Run(ctx context.Context) {}\r\n-\r\n-func (n *NOPService) Stop() {}\r\n-\r\n-func (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tif so.doSync != nil {\r\n-\t\treturn so.doSync(ctx, work)\r\n-\t}\r\n-\treturn\r\n-}\r\n-\r\n-func (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tif ao.doAsync != nil {\r\n-\t\treturn ao.doAsync(ctx, work)\r\n-\t}\r\n-\treturn\r\n-}\r\n-\r\n-func (s *implIServiceSimple) Run(ctx context.Context) {\r\n-\tif s.run != nil {\r\n-\t\ts.run(ctx)\r\n-\t}\r\n-}\r\n-\r\n-// based on ISyncOperator\r\n-func WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\r\n-\treturn WireSyncOperator(name, NewSyncOp(doSync))\r\n-}\r\n-\r\n-// based on IAsyncOperator\r\n-func WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\r\n-\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\r\n-}\r\n-\r\n-func NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\r\n-\treturn \u0026implISyncOperatorSimple{doSync: doSync}\r\n-}\r\n-\r\n-func NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\r\n-\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\r\n-}\r\n-\r\n-func NewService(run func(ctx context.Context)) IService {\r\n-\treturn \u0026implIServiceSimple{run: run}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type NOOP struct{}\n+\n+type AsyncNOOP struct{}\n+\n+type NOPService struct{}\n+\n+type implISyncOperatorSimple struct {\n+\tNOOP\n+\tdoSync func(ctx context.Context, work interface{}) (err error)\n+}\n+\n+type implAsyncOperatorSimple struct {\n+\tAsyncNOOP\n+\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\n+}\n+\n+type implIServiceSimple struct {\n+\tNOPService\n+\trun func(ctx context.Context)\n+}\n+\n+func (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn\n+}\n+\n+func (n *NOOP) Close() {}\n+\n+func (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Close() {}\n+\n+func (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\n+\n+func (n *NOPService) Prepare(work interface{}) (err error) {\n+\treturn\n+}\n+\n+func (n *NOPService) Run(ctx context.Context) {}\n+\n+func (n *NOPService) Stop() {}\n+\n+func (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tif so.doSync != nil {\n+\t\treturn so.doSync(ctx, work)\n+\t}\n+\treturn\n+}\n+\n+func (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tif ao.doAsync != nil {\n+\t\t_, _, _ = ao.doAsync, ctx, work\n+\t}\n+\treturn\n+}\n+\n+func (s *implIServiceSimple) Run(ctx context.Context) {\n+\tif s.run != nil {\n+\t\ts.run(ctx)\n+\t}\n+}\n+\n+// based on ISyncOperator\n+func WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\n+\treturn WireSyncOperator(name, NewSyncOp(doSync))\n+}\n+\n+// based on IAsyncOperator\n+func WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\n+\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\n+}\n+\n+func NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\n+\treturn \u0026implISyncOperatorSimple{doSync: doSync}\n+}\n+\n+func NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\n+\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\n+}\n+\n+func NewService(run func(ctx context.Context)) IService {\n+\treturn \u0026implIServiceSimple{run: run}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/noop-impl.go.1\" with checksum 54dd3721c8fe68d2f0f6479910df391a\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype NOOP struct{}\r\n\r\ntype AsyncNOOP struct{}\r\n\r\ntype NOPService struct{}\r\n\r\ntype implISyncOperatorSimple struct {\r\n\tNOOP\r\n\tdoSync func(ctx context.Context, work interface{}) (err error)\r\n}\r\n\r\ntype implAsyncOperatorSimple struct {\r\n\tAsyncNOOP\r\n\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\r\n}\r\n\r\ntype implIServiceSimple struct {\r\n\tNOPService\r\n\trun func(ctx context.Context)\r\n}\r\n\r\nfunc (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *NOOP) Close() {}\r\n\r\nfunc (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Close() {}\r\n\r\nfunc (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\r\n\r\nfunc (n *NOPService) Prepare(work interface{}) (err error) {\r\n\treturn\r\n}\r\n\r\nfunc (n *NOPService) Run(ctx context.Context) {}\r\n\r\nfunc (n *NOPService) Stop() {}\r\n\r\nfunc (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tif so.doSync != nil {\r\n\t\treturn so.doSync(ctx, work)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n\tif ao.doAsync != nil {\r\n\t\treturn ao.doAsync(ctx, work)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc (s *implIServiceSimple) Run(ctx context.Context) {\r\n\tif s.run != nil {\r\n\t\ts.run(ctx)\r\n\t}\r\n}\r\n\r\n// based on ISyncOperator\r\nfunc WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\r\n\treturn WireSyncOperator(name, NewSyncOp(doSync))\r\n}\r\n\r\n// based on IAsyncOperator\r\nfunc WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\r\n\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\r\n}\r\n\r\nfunc NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\r\n\treturn \u0026implISyncOperatorSimple{doSync: doSync}\r\n}\r\n\r\nfunc NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\r\n\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\r\n}\r\n\r\nfunc NewService(run func(ctx context.Context)) IService {\r\n\treturn \u0026implIServiceSimple{run: run}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype NOOP struct{}\n\ntype AsyncNOOP struct{}\n\ntype NOPService struct{}\n\ntype implISyncOperatorSimple struct {\n\tNOOP\n\tdoSync func(ctx context.Context, work interface{}) (err error)\n}\n\ntype implAsyncOperatorSimple struct {\n\tAsyncNOOP\n\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\n}\n\ntype implIServiceSimple struct {\n\tNOPService\n\trun func(ctx context.Context)\n}\n\nfunc (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn\n}\n\nfunc (n *NOOP) Close() {}\n\nfunc (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Close() {}\n\nfunc (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\n\treturn\n}\n\nfunc (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\n\nfunc (n *NOPService) Prepare(work interface{}) (err error) {\n\treturn\n}\n\nfunc (n *NOPService) Run(ctx context.Context) {}\n\nfunc (n *NOPService) Stop() {}\n\nfunc (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tif so.doSync != nil {\n\t\treturn so.doSync(ctx, work)\n\t}\n\treturn\n}\n\nfunc (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n\tif ao.doAsync != nil {\n\t\treturn ao.doAsync(ctx, work)\n\t}\n\treturn\n}\n\nfunc (s *implIServiceSimple) Run(ctx context.Context) {\n\tif s.run != nil {\n\t\t_, _ = s.run, ctx\n\t}\n}\n\n// based on ISyncOperator\nfunc WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\n\treturn WireSyncOperator(name, NewSyncOp(doSync))\n}\n\n// based on IAsyncOperator\nfunc WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\n\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\n}\n\nfunc NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\n\treturn \u0026implISyncOperatorSimple{doSync: doSync}\n}\n\nfunc NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\n\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\n}\n\nfunc NewService(run func(ctx context.Context)) IService {\n\treturn \u0026implIServiceSimple{run: run}\n}\n","originalFilePath":"noop-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,106 +1,106 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type NOOP struct{}\r\n-\r\n-type AsyncNOOP struct{}\r\n-\r\n-type NOPService struct{}\r\n-\r\n-type implISyncOperatorSimple struct {\r\n-\tNOOP\r\n-\tdoSync func(ctx context.Context, work interface{}) (err error)\r\n-}\r\n-\r\n-type implAsyncOperatorSimple struct {\r\n-\tAsyncNOOP\r\n-\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\r\n-}\r\n-\r\n-type implIServiceSimple struct {\r\n-\tNOPService\r\n-\trun func(ctx context.Context)\r\n-}\r\n-\r\n-func (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *NOOP) Close() {}\r\n-\r\n-func (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Close() {}\r\n-\r\n-func (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\r\n-\r\n-func (n *NOPService) Prepare(work interface{}) (err error) {\r\n-\treturn\r\n-}\r\n-\r\n-func (n *NOPService) Run(ctx context.Context) {}\r\n-\r\n-func (n *NOPService) Stop() {}\r\n-\r\n-func (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tif so.doSync != nil {\r\n-\t\treturn so.doSync(ctx, work)\r\n-\t}\r\n-\treturn\r\n-}\r\n-\r\n-func (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\r\n-\tif ao.doAsync != nil {\r\n-\t\treturn ao.doAsync(ctx, work)\r\n-\t}\r\n-\treturn\r\n-}\r\n-\r\n-func (s *implIServiceSimple) Run(ctx context.Context) {\r\n-\tif s.run != nil {\r\n-\t\ts.run(ctx)\r\n-\t}\r\n-}\r\n-\r\n-// based on ISyncOperator\r\n-func WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\r\n-\treturn WireSyncOperator(name, NewSyncOp(doSync))\r\n-}\r\n-\r\n-// based on IAsyncOperator\r\n-func WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\r\n-\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\r\n-}\r\n-\r\n-func NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\r\n-\treturn \u0026implISyncOperatorSimple{doSync: doSync}\r\n-}\r\n-\r\n-func NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\r\n-\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\r\n-}\r\n-\r\n-func NewService(run func(ctx context.Context)) IService {\r\n-\treturn \u0026implIServiceSimple{run: run}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type NOOP struct{}\n+\n+type AsyncNOOP struct{}\n+\n+type NOPService struct{}\n+\n+type implISyncOperatorSimple struct {\n+\tNOOP\n+\tdoSync func(ctx context.Context, work interface{}) (err error)\n+}\n+\n+type implAsyncOperatorSimple struct {\n+\tAsyncNOOP\n+\tdoAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)\n+}\n+\n+type implIServiceSimple struct {\n+\tNOPService\n+\trun func(ctx context.Context)\n+}\n+\n+func (n *NOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn\n+}\n+\n+func (n *NOOP) Close() {}\n+\n+func (n *NOOP) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Close() {}\n+\n+func (n *AsyncNOOP) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) Flush(callback OpFuncFlush) (err error) {\n+\treturn\n+}\n+\n+func (n *AsyncNOOP) OnError(ctx context.Context, err error) {}\n+\n+func (n *NOPService) Prepare(work interface{}) (err error) {\n+\treturn\n+}\n+\n+func (n *NOPService) Run(ctx context.Context) {}\n+\n+func (n *NOPService) Stop() {}\n+\n+func (so *implISyncOperatorSimple) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tif so.doSync != nil {\n+\t\treturn so.doSync(ctx, work)\n+\t}\n+\treturn\n+}\n+\n+func (ao *implAsyncOperatorSimple) DoAsync(ctx context.Context, work IWorkpiece, state IState) (outWork IWorkpiece, err error) {\n+\tif ao.doAsync != nil {\n+\t\treturn ao.doAsync(ctx, work)\n+\t}\n+\treturn\n+}\n+\n+func (s *implIServiceSimple) Run(ctx context.Context) {\n+\tif s.run != nil {\n+\t\t_, _ = s.run, ctx\n+\t}\n+}\n+\n+// based on ISyncOperator\n+func WireFunc(name string, doSync func(ctx context.Context, work interface{}) (err error)) *WiredOperator {\n+\treturn WireSyncOperator(name, NewSyncOp(doSync))\n+}\n+\n+// based on IAsyncOperator\n+func WireAsyncFunc(name string, doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) *WiredOperator {\n+\treturn WireAsyncOperator(name, NewAsyncOp(doAsync))\n+}\n+\n+func NewSyncOp(doSync func(ctx context.Context, work interface{}) (err error)) ISyncOperator {\n+\treturn \u0026implISyncOperatorSimple{doSync: doSync}\n+}\n+\n+func NewAsyncOp(doAsync func(ctx context.Context, work IWorkpiece) (outWork IWorkpiece, err error)) IAsyncOperator {\n+\treturn \u0026implAsyncOperatorSimple{doAsync: doAsync}\n+}\n+\n+func NewService(run func(ctx context.Context)) IService {\n+\treturn \u0026implIServiceSimple{run: run}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/noop-impl.go.2\" with checksum 97c47e89504e7ff3dd3a81edbbee304f\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\t_, _, _ = err, errors.New, queryStateQuotaExceed\n\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\t_, _, _ = err, errors.New, queryStateQuotaExceed\n+\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.2\" with checksum bbbff664a757665909808fdd6945d3d8\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.3\" with checksum 9d1809ed15852f0cbb4c0e7ad32a0723\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.4\" with checksum a022cbc212662ef77c8b2aa62e94d5e9\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\t_ = e\n\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\t_ = e\n+\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.5\" with checksum 4cb4f9129979064bf248c8b0c520eab9\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\t_ = e\n\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\t_ = e\n+\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.6\" with checksum 109d77ce016eb0c5704e9f1f49431274\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\t_, _ = fmt.Errorf, itemNotExists\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\t_, _ = fmt.Errorf, itemNotExists\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.7\" with checksum 0db98bdaef77230e49b124d7237e34cf\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\t_, _ = fmt.Errorf, itemExists\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\t_, _ = fmt.Errorf, itemExists\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.8\" with checksum a7e599bd4c67730446f641cb66e63558\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\t_, _, _, _ = val, state.items, items, i\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,151 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\t_, _, _, _ = val, state.items, items, i\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.9\" with checksum 13bca52afb743327e2805534dbdd49d1\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.12\" with checksum eee1d348ff9617d292a531dff6499721\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.14\" with checksum c0e40fff1b624962cff77c58cd316df6\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.15\" with checksum ed80850afd9993ec18b43be10812165a\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.16\" with checksum b684e0c3ccd5c86df6c8a900c3614f5c\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.17\" with checksum 4343d5595469b3b8c2f3f03fff1021be\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\t_ = operator\n\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\t_ = operator\n+\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.18\" with checksum 855cbbc7bc133af767b75b9278f3c28b\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.19\" with checksum 0d9cc9f4313d68ef5af1edc9df66f277\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\t_ = err\n\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\t_ = err\n+\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.20\" with checksum 604f31fa7a10124a9802cc65f76e3af8\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 true {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 true {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.23\" with checksum 29b4831a54c82626616facec0e512e23\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif true \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif true \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.24\" with checksum 52248e6b2c65e207d84097e9448a6e5b\n"},{"mutator":{"mutatorName":"loop/condition","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor 1 \u003c 1 {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor 1 \u003c 1 {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.28\" with checksum a398c3b48b974e2b0ab1453d6614f440\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tbreak\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,154 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tbreak\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.29\" with checksum 23f8ead61ab944a209b4e0a52cdfceee\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tbreak\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,154 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tbreak\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.30\" with checksum f633ea7dc46dc423553035ae324a2817\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\tbreak\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,154 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\tbreak\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.31\" with checksum 33891d741823d20f2d797c54c936a382\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tbreak\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,154 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tbreak\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.32\" with checksum daa94f7c3ed657cc741b36e74d63b0a5\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tbreak\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,154 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tbreak\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.33\" with checksum 2ec5b7e76959f62a9c65e1776e5365ac\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\tbreak\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,154 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\tbreak\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.34\" with checksum 51a56118ff0e5af6e7e339fda872d285\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 0\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 0\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.35\" with checksum 21fc6c5c56d01dbde1d4da35d56368ec\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 1, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 1, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.38\" with checksum afc1bc6455fccbb2aadc182b54d7d54d\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\t_, _ = state, NewState\n\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\t_, _ = state, NewState\n+\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.39\" with checksum d849964fe047246084f07cb2b392a56a\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\t\t_, _, _, _, _ = fQueryState, err, queryState.doQuery, fQueryState, state\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,151 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\t\t_, _, _, _, _ = fQueryState, err, queryState.doQuery, fQueryState, state\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.40\" with checksum 4a3dc882234f7bb6ec50fdd03dad2149\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\t_ = queryCounter\n\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\t_ = queryCounter\n+\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.41\" with checksum 55ac6f9fae97a5f5482eea5c7837c9fc\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\t_, _, _ = err, errors.New, queryStateQuotaExceed\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\t_, _, _ = err, errors.New, queryStateQuotaExceed\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.42\" with checksum c8e82fc084993d88eebe2b1a09cdec65\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\t_ = storage\n\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\t_ = storage\n+\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.43\" with checksum 7067eef6bbd1681dbb77cbebfa03bfcb\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\t_ = val\n\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\t_ = val\n+\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.44\" with checksum 20cf061e49ef9f3ebce0a312c1dce9e3\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\t_, _, _ = state.items, items, i\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\t_, _, _ = state.items, items, i\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.45\" with checksum 8e1efef2b44153916b978e18eda405c5\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\t_, _, _ = ii, ii, item\n\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,153 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\t_, _, _ = ii, ii, item\n+\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.46\" with checksum eb5b8a18f9afb12fc25d117abd20bedf\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\t_, _, _ = itemsPerStorage, item.storageID, ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\t_, _, _ = itemsPerStorage, item.storageID, ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.47\" with checksum ea875cfa65b9e77c43adffa937277192\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n)\r\n\r\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n\tstate = NewState()\r\n\tqueryState := NewQueryState(storages)\r\n\tqueryCounter := 1\r\n\tfor fQueryState != nil {\r\n\t\tif queryCounter \u003e maxPrepareQueries {\r\n\t\t\terr = errors.New(queryStateQuotaExceed)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tqueryCounter++\r\n\t}\r\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n\t\treturn nil, e\r\n\t}\r\n\treturn state, nil\r\n}\r\n\r\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n\titems := queryState.getAddedItems()\r\n\tfor i := range items {\r\n\t\tstorage := storages.GetStorage(items[i].storageID)\r\n\t\titems[i].storage = storage\r\n\t\tval, e := storage.Get(items[i].key)\r\n\t\tif e != nil {\r\n\t\t\treturn e\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n\t\t}\r\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n\t\t}\r\n\t\tif items[i].alias != \"\" {\r\n\t\t\titems[i].value = val\r\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n\t\treturn\r\n\t}\r\n\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n\tfor _, item := range items {\r\n\t\tii := itemsPerStorage[item.storageID]\r\n\t\tii = append(ii, item)\r\n\t\titemsPerStorage[item.storageID] = ii\r\n\t}\r\n\tfor storageID, batchItems := range itemsPerStorage {\r\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, create := range queryState.willCreate {\r\n\t\tstorage := storages.GetStorage(create.storageID)\r\n\t\tbuilder, err := storage.New(create.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = create.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: create.storageID,\r\n\t\t\tKey:       create.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n\tfor _, put := range queryState.willPut {\r\n\t\tstorage := storages.GetStorage(put.storageID)\r\n\t\tbuilder, err := storage.Put(put.key)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = put.fnew(work, state, builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: put.storageID,\r\n\t\t\tKey:       put.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc fpanic(operator string, msg string) {\r\n\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n}\r\n\r\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n\tfor _, update := range queryState.willUpdate {\r\n\t\titem, ok := state.items[update.alias]\r\n\t\tif (!ok) || item.kind != qsiMustExist {\r\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n\t\t}\r\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\t*items = append(*items, BatchItem{\r\n\t\t\tstorageID: item.storageID,\r\n\t\t\tKey:       item.key,\r\n\t\t\tValue:     builder,\r\n\t\t})\r\n\t}\r\n\treturn nil\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n\tstate = NewState()\n\tqueryState := NewQueryState(storages)\n\tqueryCounter := 1\n\tfor fQueryState != nil {\n\t\tif queryCounter \u003e maxPrepareQueries {\n\t\t\terr = errors.New(queryStateQuotaExceed)\n\t\t\treturn\n\t\t}\n\n\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n\t\t\treturn\n\t\t}\n\t\tqueryCounter++\n\t}\n\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n\t\treturn nil, e\n\t}\n\treturn state, nil\n}\n\nfunc handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n\titems := queryState.getAddedItems()\n\tfor i := range items {\n\t\tstorage := storages.GetStorage(items[i].storageID)\n\t\titems[i].storage = storage\n\t\tval, e := storage.Get(items[i].key)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n\t\t}\n\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n\t\t}\n\t\tif items[i].alias != \"\" {\n\t\t\titems[i].value = val\n\t\t\tstate.items[items[i].alias] = \u0026items[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n\t\treturn\n\t}\n\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n\t\treturn\n\t}\n\titemsPerStorage := make(map[StorageID][]BatchItem)\n\tfor _, item := range items {\n\t\tii := itemsPerStorage[item.storageID]\n\t\tii = append(ii, item)\n\t\titemsPerStorage[item.storageID] = ii\n\t}\n\tfor storageID, batchItems := range itemsPerStorage {\n\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, create := range queryState.willCreate {\n\t\tstorage := storages.GetStorage(create.storageID)\n\t\tbuilder, err := storage.New(create.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = create.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: create.storageID,\n\t\t\tKey:       create.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n\tfor _, put := range queryState.willPut {\n\t\tstorage := storages.GetStorage(put.storageID)\n\t\tbuilder, err := storage.Put(put.key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = put.fnew(work, state, builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: put.storageID,\n\t\t\tKey:       put.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc fpanic(operator string, msg string) {\n\t_, _, _ = fmt.Sprintf, operator, msg\n}\n\nfunc willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n\tfor _, update := range queryState.willUpdate {\n\t\titem, ok := state.items[update.alias]\n\t\tif (!ok) || item.kind != qsiMustExist {\n\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n\t\t}\n\t\tbuilder, err := item.storage.Update(item.key, item.value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*items = append(*items, BatchItem{\n\t\t\tstorageID: item.storageID,\n\t\t\tKey:       item.key,\n\t\t\tValue:     builder,\n\t\t})\n\t}\n\treturn nil\n}\n","originalFilePath":"prepare.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,152 +1,152 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\r\n-\tstate = NewState()\r\n-\tqueryState := NewQueryState(storages)\r\n-\tqueryCounter := 1\r\n-\tfor fQueryState != nil {\r\n-\t\tif queryCounter \u003e maxPrepareQueries {\r\n-\t\t\terr = errors.New(queryStateQuotaExceed)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\r\n-\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\r\n-\t\tif err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t\tqueryCounter++\r\n-\t}\r\n-\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\r\n-\t\treturn nil, e\r\n-\t}\r\n-\treturn state, nil\r\n-}\r\n-\r\n-func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\r\n-\titems := queryState.getAddedItems()\r\n-\tfor i := range items {\r\n-\t\tstorage := storages.GetStorage(items[i].storageID)\r\n-\t\titems[i].storage = storage\r\n-\t\tval, e := storage.Get(items[i].key)\r\n-\t\tif e != nil {\r\n-\t\t\treturn e\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\r\n-\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\r\n-\t\t}\r\n-\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\r\n-\t\t\treturn fmt.Errorf(itemExists, items[i].key)\r\n-\t\t}\r\n-\t\tif items[i].alias != \"\" {\r\n-\t\t\titems[i].value = val\r\n-\t\t\tstate.items[items[i].alias] = \u0026items[i]\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\r\n-\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\r\n-\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\r\n-\t\treturn\r\n-\t}\r\n-\titemsPerStorage := make(map[StorageID][]BatchItem)\r\n-\tfor _, item := range items {\r\n-\t\tii := itemsPerStorage[item.storageID]\r\n-\t\tii = append(ii, item)\r\n-\t\titemsPerStorage[item.storageID] = ii\r\n-\t}\r\n-\tfor storageID, batchItems := range itemsPerStorage {\r\n-\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, create := range queryState.willCreate {\r\n-\t\tstorage := storages.GetStorage(create.storageID)\r\n-\t\tbuilder, err := storage.New(create.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = create.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: create.storageID,\r\n-\t\t\tKey:       create.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\r\n-\tfor _, put := range queryState.willPut {\r\n-\t\tstorage := storages.GetStorage(put.storageID)\r\n-\t\tbuilder, err := storage.Put(put.key)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = put.fnew(work, state, builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: put.storageID,\r\n-\t\t\tKey:       put.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func fpanic(operator string, msg string) {\r\n-\tpanic(fmt.Sprintf(\"critical error in '%s': %s\", operator, msg))\r\n-}\r\n-\r\n-func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\r\n-\tfor _, update := range queryState.willUpdate {\r\n-\t\titem, ok := state.items[update.alias]\r\n-\t\tif (!ok) || item.kind != qsiMustExist {\r\n-\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\r\n-\t\t}\r\n-\t\tbuilder, err := item.storage.Update(item.key, item.value)\r\n-\t\tif err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\r\n-\t\t\treturn err\r\n-\t\t}\r\n-\t\t*items = append(*items, BatchItem{\r\n-\t\t\tstorageID: item.storageID,\r\n-\t\t\tKey:       item.key,\r\n-\t\t\tValue:     builder,\r\n-\t\t})\r\n-\t}\r\n-\treturn nil\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+func Prepare(operator string, work interface{}, fQueryState OpFuncQueryState, storages IStorages, maxPrepareQueries int) (state *State, err error) {\n+\tstate = NewState()\n+\tqueryState := NewQueryState(storages)\n+\tqueryCounter := 1\n+\tfor fQueryState != nil {\n+\t\tif queryCounter \u003e maxPrepareQueries {\n+\t\t\terr = errors.New(queryStateQuotaExceed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tfQueryState, err = queryState.doQuery(fQueryState, state)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err = handleQsAddedItems(queryState, state, storages); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tqueryCounter++\n+\t}\n+\tif e := applyQsItems(operator, work, queryState, state, storages); e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn state, nil\n+}\n+\n+func handleQsAddedItems(queryState *QueryState, state *State, storages IStorages) error {\n+\titems := queryState.getAddedItems()\n+\tfor i := range items {\n+\t\tstorage := storages.GetStorage(items[i].storageID)\n+\t\titems[i].storage = storage\n+\t\tval, e := storage.Get(items[i].key)\n+\t\tif e != nil {\n+\t\t\treturn e\n+\t\t}\n+\t\tif items[i].kind == qsiMustExist \u0026\u0026 val == nil {\n+\t\t\treturn fmt.Errorf(itemNotExists, items[i].alias)\n+\t\t}\n+\t\tif items[i].kind == qsiMustNotExist \u0026\u0026 val != nil {\n+\t\t\treturn fmt.Errorf(itemExists, items[i].key)\n+\t\t}\n+\t\tif items[i].alias != \"\" {\n+\t\t\titems[i].value = val\n+\t\t\tstate.items[items[i].alias] = \u0026items[i]\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func applyQsItems(operator string, work interface{}, queryState *QueryState, state *State, storages IStorages) (err error) {\n+\titems := make([]BatchItem, 0, len(queryState.willCreate)+len(queryState.willUpdate)+len(queryState.willUpdate))\n+\tif err = willCreate(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willUpdate(operator, work, queryState, state, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\tif err = willPut(work, queryState, state, storages, \u0026items); err != nil {\n+\t\treturn\n+\t}\n+\titemsPerStorage := make(map[StorageID][]BatchItem)\n+\tfor _, item := range items {\n+\t\tii := itemsPerStorage[item.storageID]\n+\t\tii = append(ii, item)\n+\t\titemsPerStorage[item.storageID] = ii\n+\t}\n+\tfor storageID, batchItems := range itemsPerStorage {\n+\t\terr = storages.GetStorage(storageID).ApplyBatch(batchItems)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func willCreate(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, create := range queryState.willCreate {\n+\t\tstorage := storages.GetStorage(create.storageID)\n+\t\tbuilder, err := storage.New(create.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = create.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: create.storageID,\n+\t\t\tKey:       create.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func willPut(work interface{}, queryState *QueryState, state *State, storages IStorages, items *[]BatchItem) error {\n+\tfor _, put := range queryState.willPut {\n+\t\tstorage := storages.GetStorage(put.storageID)\n+\t\tbuilder, err := storage.Put(put.key)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = put.fnew(work, state, builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: put.storageID,\n+\t\t\tKey:       put.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n+\n+func fpanic(operator string, msg string) {\n+\t_, _, _ = fmt.Sprintf, operator, msg\n+}\n+\n+func willUpdate(operator string, work interface{}, queryState *QueryState, state *State, items *[]BatchItem) error {\n+\tfor _, update := range queryState.willUpdate {\n+\t\titem, ok := state.items[update.alias]\n+\t\tif (!ok) || item.kind != qsiMustExist {\n+\t\t\tfpanic(operator, \"willUpdate item must be first queried with MustExist\")\n+\t\t}\n+\t\tbuilder, err := item.storage.Update(item.key, item.value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = update.fupd(work, state, item.value.Value(), builder); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*items = append(*items, BatchItem{\n+\t\t\tstorageID: item.storageID,\n+\t\t\tKey:       item.key,\n+\t\t\tValue:     builder,\n+\t\t})\n+\t}\n+\treturn nil\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/prepare.go.51\" with checksum b840b3180c68a5771ac1e9974da29857\n"},{"mutator":{"mutatorName":"arithmetic/base","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)+qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)+qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.0\" with checksum bedc62454f51e9c8dc0eeee01a35612c\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.1\" with checksum 66bc6b4815d49124262e4e5a5d653947\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: -1,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: -1,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.6\" with checksum 992b18c4fdeb833d6c253de2f85c881b\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = -1\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = -1\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.7\" with checksum 1ba082ba82d3f761e8dd37e9f1cce3ce\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 1),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 1),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.9\" with checksum a948a9b629b7162fdcce6c59cbdcbf42\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 1),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 1),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.10\" with checksum acb342374950da00a32b81a46eaeeac4\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 1),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 1),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.11\" with checksum 6216b8325665aca334a9d02c84272b4e\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 1,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 1,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.12\" with checksum f3471179e0a3ddae601a46d7f3950843\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 1\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 1\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.13\" with checksum b79d02a3b6ca944467c34e053ddaf415\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\t_ = qs.addedItems\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\t_ = qs.addedItems\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.16\" with checksum 6c24a5a9c5d6cebb60ce40d6a94aa176\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\t_ = qs.addedItems\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\t_ = qs.addedItems\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.18\" with checksum 6f91bc5e6ab981b89bb7adfd3e831821\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype QueryState struct {\r\n\tstorages   IStorages\r\n\titems      []queryStateItem\r\n\twillUpdate []updateIntent\r\n\twillCreate []createIntent\r\n\twillPut    []createIntent\r\n\taddedItems int\r\n}\r\n\r\nfunc NewQueryState(st IStorages) *QueryState {\r\n\treturn \u0026QueryState{\r\n\t\tstorages:   st,\r\n\t\titems:      make([]queryStateItem, 0),\r\n\t\twillUpdate: make([]updateIntent, 0),\r\n\t\twillCreate: make([]createIntent, 0),\r\n\t\twillPut:    make([]createIntent, 0),\r\n\t\taddedItems: 0,\r\n\t}\r\n}\r\n\r\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\r\n\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n}\r\n\r\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n\tqs.addedItems = 0\r\n\treturn fQueryState(qs, state)\r\n}\r\n\r\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n}\r\n\r\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiMustNotExist,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n\tif alias == \"\" {\r\n\t\tpanic(\"alias is empty on CanExist\")\r\n\t}\r\n\tqs.items = append(qs.items, queryStateItem{\r\n\t\tkind:      qsiCanExist,\r\n\t\talias:     alias,\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t})\r\n\tqs.addedItems++\r\n}\r\n\r\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n\t\talias: alias,\r\n\t\tfupd:  fupd,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willCreate = append(qs.willCreate, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n\r\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n\tqs.willPut = append(qs.willPut, createIntent{\r\n\t\tstorageID: storageID,\r\n\t\tkey:       key,\r\n\t\tfnew:      fnew,\r\n\t})\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype QueryState struct {\n\tstorages   IStorages\n\titems      []queryStateItem\n\twillUpdate []updateIntent\n\twillCreate []createIntent\n\twillPut    []createIntent\n\taddedItems int\n}\n\nfunc NewQueryState(st IStorages) *QueryState {\n\treturn \u0026QueryState{\n\t\tstorages:   st,\n\t\titems:      make([]queryStateItem, 0),\n\t\twillUpdate: make([]updateIntent, 0),\n\t\twillCreate: make([]createIntent, 0),\n\t\twillPut:    make([]createIntent, 0),\n\t\taddedItems: 0,\n\t}\n}\n\nfunc (qs *QueryState) getAddedItems() []queryStateItem {\n\treturn qs.items[len(qs.items)-qs.addedItems:]\n}\n\nfunc (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n\tqs.addedItems = 0\n\treturn fQueryState(qs, state)\n}\n\nfunc (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n}\n\nfunc (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiMustNotExist,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\tqs.addedItems++\n}\n\nfunc (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n\tif alias == \"\" {\n\t\tpanic(\"alias is empty on CanExist\")\n\t}\n\tqs.items = append(qs.items, queryStateItem{\n\t\tkind:      qsiCanExist,\n\t\talias:     alias,\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t})\n\t_ = qs.addedItems\n}\n\nfunc (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n\t\talias: alias,\n\t\tfupd:  fupd,\n\t})\n}\n\nfunc (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willCreate = append(qs.willCreate, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n\nfunc (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n\tqs.willPut = append(qs.willPut, createIntent{\n\t\tstorageID: storageID,\n\t\tkey:       key,\n\t\tfnew:      fnew,\n\t})\n}\n","originalFilePath":"query-state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,93 +1,93 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type QueryState struct {\r\n-\tstorages   IStorages\r\n-\titems      []queryStateItem\r\n-\twillUpdate []updateIntent\r\n-\twillCreate []createIntent\r\n-\twillPut    []createIntent\r\n-\taddedItems int\r\n-}\r\n-\r\n-func NewQueryState(st IStorages) *QueryState {\r\n-\treturn \u0026QueryState{\r\n-\t\tstorages:   st,\r\n-\t\titems:      make([]queryStateItem, 0),\r\n-\t\twillUpdate: make([]updateIntent, 0),\r\n-\t\twillCreate: make([]createIntent, 0),\r\n-\t\twillPut:    make([]createIntent, 0),\r\n-\t\taddedItems: 0,\r\n-\t}\r\n-}\r\n-\r\n-func (qs *QueryState) getAddedItems() []queryStateItem {\r\n-\treturn qs.items[len(qs.items)-qs.addedItems:]\r\n-}\r\n-\r\n-func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\r\n-\tqs.addedItems = 0\r\n-\treturn fQueryState(qs, state)\r\n-}\r\n-\r\n-func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\r\n-\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\r\n-}\r\n-\r\n-func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiMustNotExist,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\r\n-\tif alias == \"\" {\r\n-\t\tpanic(\"alias is empty on CanExist\")\r\n-\t}\r\n-\tqs.items = append(qs.items, queryStateItem{\r\n-\t\tkind:      qsiCanExist,\r\n-\t\talias:     alias,\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t})\r\n-\tqs.addedItems++\r\n-}\r\n-\r\n-func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\r\n-\tqs.willUpdate = append(qs.willUpdate, updateIntent{\r\n-\t\talias: alias,\r\n-\t\tfupd:  fupd,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willCreate = append(qs.willCreate, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n-\r\n-func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\r\n-\tqs.willPut = append(qs.willPut, createIntent{\r\n-\t\tstorageID: storageID,\r\n-\t\tkey:       key,\r\n-\t\tfnew:      fnew,\r\n-\t})\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type QueryState struct {\n+\tstorages   IStorages\n+\titems      []queryStateItem\n+\twillUpdate []updateIntent\n+\twillCreate []createIntent\n+\twillPut    []createIntent\n+\taddedItems int\n+}\n+\n+func NewQueryState(st IStorages) *QueryState {\n+\treturn \u0026QueryState{\n+\t\tstorages:   st,\n+\t\titems:      make([]queryStateItem, 0),\n+\t\twillUpdate: make([]updateIntent, 0),\n+\t\twillCreate: make([]createIntent, 0),\n+\t\twillPut:    make([]createIntent, 0),\n+\t\taddedItems: 0,\n+\t}\n+}\n+\n+func (qs *QueryState) getAddedItems() []queryStateItem {\n+\treturn qs.items[len(qs.items)-qs.addedItems:]\n+}\n+\n+func (qs *QueryState) doQuery(fQueryState OpFuncQueryState, state IState) (OpFuncQueryState, error) {\n+\tqs.addedItems = 0\n+\treturn fQueryState(qs, state)\n+}\n+\n+func (qs *QueryState) KeyBuilderFactory(storageID StorageID) KeyBuilderFactory {\n+\treturn qs.storages.GetStorage(storageID).KeyBuilderFactory()\n+}\n+\n+func (qs *QueryState) MustExist(alias string, storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) MustNotExist(storageID StorageID, key interface{}) {\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiMustNotExist,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\tqs.addedItems++\n+}\n+\n+func (qs *QueryState) CanExist(alias string, storageID StorageID, key interface{}) {\n+\tif alias == \"\" {\n+\t\tpanic(\"alias is empty on CanExist\")\n+\t}\n+\tqs.items = append(qs.items, queryStateItem{\n+\t\tkind:      qsiCanExist,\n+\t\talias:     alias,\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t})\n+\t_ = qs.addedItems\n+}\n+\n+func (qs *QueryState) WillUpdate(alias string, fupd OpFuncUpdate) {\n+\tqs.willUpdate = append(qs.willUpdate, updateIntent{\n+\t\talias: alias,\n+\t\tfupd:  fupd,\n+\t})\n+}\n+\n+func (qs *QueryState) WillCreate(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willCreate = append(qs.willCreate, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n+\n+func (qs *QueryState) WillPut(storageID StorageID, key interface{}, fnew OpFuncNew) {\n+\tqs.willPut = append(qs.willPut, createIntent{\n+\t\tstorageID: storageID,\n+\t\tkey:       key,\n+\t\tfnew:      fnew,\n+\t})\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/query-state-impl.go.20\" with checksum d0db7a8f9d7be963cdcf5dab84bfcd61\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.0\" with checksum da22230d734f52dc4d7013c791d04a17\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.1\" with checksum 29e2955a782c5dad93a1c4ba19b4a3f6\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.2\" with checksum e8f8f8a3661d5f9d533c94859a702c52\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\t_ = so.serviceDone\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\t_ = so.serviceDone\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.3\" with checksum 2bdf2739ee5d0463117fe6282a2e42b9\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\t_ = so.iService.Stop\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\t_ = so.iService.Stop\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.5\" with checksum ecbd374f230c3c18bce349dde7efbcf2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t_ = so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t_ = so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.6\" with checksum b6c855980dd784493e3761f80a63a42a\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\t_ = so.isStarted\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\t_ = so.isStarted\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.7\" with checksum 3aff80e2811ba973e58e6cda4265d557\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\t_, _ = so.iService.Run, ctx\n\t\tclose(so.serviceDone)\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\t_, _ = so.iService.Run, ctx\n+\t\tclose(so.serviceDone)\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.8\" with checksum 12a8439a1f4a2b6c5f284d3558ad7208\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n)\r\n\r\ntype serviceOperator struct {\r\n\tserviceDone chan struct{}\r\n\tiService    IService\r\n\tisStarted   bool\r\n}\r\n\r\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\tif so.serviceDone != nil {\r\n\t\tpanic(\"already prepared\")\r\n\t}\r\n\tso.serviceDone = make(chan struct{})\r\n\treturn nil, so.iService.Prepare(work)\r\n}\r\n\r\nfunc (so *serviceOperator) Close() {\r\n\tif !so.isStarted {\r\n\t\treturn\r\n\t}\r\n\tso.iService.Stop()\r\n\t\u003c-so.serviceDone\r\n}\r\n\r\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\tso.isStarted = true\r\n\tgo func() {\r\n\t\tso.iService.Run(ctx)\r\n\t\tclose(so.serviceDone)\r\n\t}()\r\n\treturn\r\n}\r\n\r\nfunc ServiceOperator(service IService) ISyncOperator {\r\n\tif service == nil {\r\n\t\tpanic(\"service logic must not be nil\")\r\n\t}\r\n\treturn \u0026serviceOperator{\r\n\t\tiService: service,\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n)\n\ntype serviceOperator struct {\n\tserviceDone chan struct{}\n\tiService    IService\n\tisStarted   bool\n}\n\nfunc (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\tif so.serviceDone != nil {\n\t\tpanic(\"already prepared\")\n\t}\n\tso.serviceDone = make(chan struct{})\n\treturn nil, so.iService.Prepare(work)\n}\n\nfunc (so *serviceOperator) Close() {\n\tif !so.isStarted {\n\t\treturn\n\t}\n\tso.iService.Stop()\n\t\u003c-so.serviceDone\n}\n\nfunc (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\tso.isStarted = true\n\tgo func() {\n\t\tso.iService.Run(ctx)\n\t\t_ = so.serviceDone\n\t}()\n\treturn\n}\n\nfunc ServiceOperator(service IService) ISyncOperator {\n\tif service == nil {\n\t\tpanic(\"service logic must not be nil\")\n\t}\n\treturn \u0026serviceOperator{\n\t\tiService: service,\n\t}\n}\n","originalFilePath":"service-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,49 +1,49 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-)\r\n-\r\n-type serviceOperator struct {\r\n-\tserviceDone chan struct{}\r\n-\tiService    IService\r\n-\tisStarted   bool\r\n-}\r\n-\r\n-func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\tif so.serviceDone != nil {\r\n-\t\tpanic(\"already prepared\")\r\n-\t}\r\n-\tso.serviceDone = make(chan struct{})\r\n-\treturn nil, so.iService.Prepare(work)\r\n-}\r\n-\r\n-func (so *serviceOperator) Close() {\r\n-\tif !so.isStarted {\r\n-\t\treturn\r\n-\t}\r\n-\tso.iService.Stop()\r\n-\t\u003c-so.serviceDone\r\n-}\r\n-\r\n-func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\tso.isStarted = true\r\n-\tgo func() {\r\n-\t\tso.iService.Run(ctx)\r\n-\t\tclose(so.serviceDone)\r\n-\t}()\r\n-\treturn\r\n-}\r\n-\r\n-func ServiceOperator(service IService) ISyncOperator {\r\n-\tif service == nil {\r\n-\t\tpanic(\"service logic must not be nil\")\r\n-\t}\r\n-\treturn \u0026serviceOperator{\r\n-\t\tiService: service,\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+)\n+\n+type serviceOperator struct {\n+\tserviceDone chan struct{}\n+\tiService    IService\n+\tisStarted   bool\n+}\n+\n+func (so *serviceOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\tif so.serviceDone != nil {\n+\t\tpanic(\"already prepared\")\n+\t}\n+\tso.serviceDone = make(chan struct{})\n+\treturn nil, so.iService.Prepare(work)\n+}\n+\n+func (so *serviceOperator) Close() {\n+\tif !so.isStarted {\n+\t\treturn\n+\t}\n+\tso.iService.Stop()\n+\t\u003c-so.serviceDone\n+}\n+\n+func (so *serviceOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\tso.isStarted = true\n+\tgo func() {\n+\t\tso.iService.Run(ctx)\n+\t\t_ = so.serviceDone\n+\t}()\n+\treturn\n+}\n+\n+func ServiceOperator(service IService) ISyncOperator {\n+\tif service == nil {\n+\t\tpanic(\"service logic must not be nil\")\n+\t}\n+\treturn \u0026serviceOperator{\n+\t\tiService: service,\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/service-operator-impl.go.9\" with checksum 2240fca0f451a00eaaaf72697657effa\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype State struct {\r\n\titems        map[string]*queryStateItem\r\n\toperatorName string\r\n\twctx         IWorkpieceContext\r\n}\r\n\r\nfunc NewState() *State {\r\n\treturn \u0026State{\r\n\t\titems: make(map[string]*queryStateItem),\r\n\t}\r\n}\r\n\r\n// alias must be used before in MustExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) Get(alias string) (value interface{}) {\r\n\tvar ok bool\r\n\tvar item *queryStateItem\r\n\tif item, ok = s.items[alias]; !ok {\r\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\treturn item.value.Value()\r\n}\r\n\r\n// alias must be used before in CanExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n\titem, ok := s.items[alias]\r\n\tif !ok {\r\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\treturn false, nil\r\n\t}\r\n\treturn true, item.value.Value()\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype State struct {\n\titems        map[string]*queryStateItem\n\toperatorName string\n\twctx         IWorkpieceContext\n}\n\nfunc NewState() *State {\n\treturn \u0026State{\n\t\titems: make(map[string]*queryStateItem),\n\t}\n}\n\n// alias must be used before in MustExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) Get(alias string) (value interface{}) {\n\tvar ok bool\n\tvar item *queryStateItem\n\tif item, ok = s.items[alias]; !ok {\n\t\t_, _, _, _ = pipelinePanic, alias, s.operatorName, s.wctx\n\t}\n\tif item.value == nil {\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\n\t}\n\treturn item.value.Value()\n}\n\n// alias must be used before in CanExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n\titem, ok := s.items[alias]\n\tif !ok {\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\n\t}\n\tif item.value == nil {\n\t\treturn false, nil\n\t}\n\treturn true, item.value.Value()\n}\n","originalFilePath":"state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,44 +1,44 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type State struct {\r\n-\titems        map[string]*queryStateItem\r\n-\toperatorName string\r\n-\twctx         IWorkpieceContext\r\n-}\r\n-\r\n-func NewState() *State {\r\n-\treturn \u0026State{\r\n-\t\titems: make(map[string]*queryStateItem),\r\n-\t}\r\n-}\r\n-\r\n-// alias must be used before in MustExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) Get(alias string) (value interface{}) {\r\n-\tvar ok bool\r\n-\tvar item *queryStateItem\r\n-\tif item, ok = s.items[alias]; !ok {\r\n-\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\treturn item.value.Value()\r\n-}\r\n-\r\n-// alias must be used before in CanExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n-\titem, ok := s.items[alias]\r\n-\tif !ok {\r\n-\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\treturn false, nil\r\n-\t}\r\n-\treturn true, item.value.Value()\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type State struct {\n+\titems        map[string]*queryStateItem\n+\toperatorName string\n+\twctx         IWorkpieceContext\n+}\n+\n+func NewState() *State {\n+\treturn \u0026State{\n+\t\titems: make(map[string]*queryStateItem),\n+\t}\n+}\n+\n+// alias must be used before in MustExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) Get(alias string) (value interface{}) {\n+\tvar ok bool\n+\tvar item *queryStateItem\n+\tif item, ok = s.items[alias]; !ok {\n+\t\t_, _, _, _ = pipelinePanic, alias, s.operatorName, s.wctx\n+\t}\n+\tif item.value == nil {\n+\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\treturn item.value.Value()\n+}\n+\n+// alias must be used before in CanExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n+\titem, ok := s.items[alias]\n+\tif !ok {\n+\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\tif item.value == nil {\n+\t\treturn false, nil\n+\t}\n+\treturn true, item.value.Value()\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/state-impl.go.3\" with checksum e696b09b3c7f4c1fe2ec125fd349a999\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype State struct {\r\n\titems        map[string]*queryStateItem\r\n\toperatorName string\r\n\twctx         IWorkpieceContext\r\n}\r\n\r\nfunc NewState() *State {\r\n\treturn \u0026State{\r\n\t\titems: make(map[string]*queryStateItem),\r\n\t}\r\n}\r\n\r\n// alias must be used before in MustExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) Get(alias string) (value interface{}) {\r\n\tvar ok bool\r\n\tvar item *queryStateItem\r\n\tif item, ok = s.items[alias]; !ok {\r\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\treturn item.value.Value()\r\n}\r\n\r\n// alias must be used before in CanExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n\titem, ok := s.items[alias]\r\n\tif !ok {\r\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\treturn false, nil\r\n\t}\r\n\treturn true, item.value.Value()\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype State struct {\n\titems        map[string]*queryStateItem\n\toperatorName string\n\twctx         IWorkpieceContext\n}\n\nfunc NewState() *State {\n\treturn \u0026State{\n\t\titems: make(map[string]*queryStateItem),\n\t}\n}\n\n// alias must be used before in MustExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) Get(alias string) (value interface{}) {\n\tvar ok bool\n\tvar item *queryStateItem\n\tif item, ok = s.items[alias]; !ok {\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\n\t}\n\tif item.value == nil {\n\t\t_, _, _, _ = pipelinePanic, alias, s.operatorName, s.wctx\n\t}\n\treturn item.value.Value()\n}\n\n// alias must be used before in CanExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n\titem, ok := s.items[alias]\n\tif !ok {\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\n\t}\n\tif item.value == nil {\n\t\treturn false, nil\n\t}\n\treturn true, item.value.Value()\n}\n","originalFilePath":"state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,44 +1,44 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type State struct {\r\n-\titems        map[string]*queryStateItem\r\n-\toperatorName string\r\n-\twctx         IWorkpieceContext\r\n-}\r\n-\r\n-func NewState() *State {\r\n-\treturn \u0026State{\r\n-\t\titems: make(map[string]*queryStateItem),\r\n-\t}\r\n-}\r\n-\r\n-// alias must be used before in MustExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) Get(alias string) (value interface{}) {\r\n-\tvar ok bool\r\n-\tvar item *queryStateItem\r\n-\tif item, ok = s.items[alias]; !ok {\r\n-\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\treturn item.value.Value()\r\n-}\r\n-\r\n-// alias must be used before in CanExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n-\titem, ok := s.items[alias]\r\n-\tif !ok {\r\n-\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\treturn false, nil\r\n-\t}\r\n-\treturn true, item.value.Value()\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type State struct {\n+\titems        map[string]*queryStateItem\n+\toperatorName string\n+\twctx         IWorkpieceContext\n+}\n+\n+func NewState() *State {\n+\treturn \u0026State{\n+\t\titems: make(map[string]*queryStateItem),\n+\t}\n+}\n+\n+// alias must be used before in MustExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) Get(alias string) (value interface{}) {\n+\tvar ok bool\n+\tvar item *queryStateItem\n+\tif item, ok = s.items[alias]; !ok {\n+\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\tif item.value == nil {\n+\t\t_, _, _, _ = pipelinePanic, alias, s.operatorName, s.wctx\n+\t}\n+\treturn item.value.Value()\n+}\n+\n+// alias must be used before in CanExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n+\titem, ok := s.items[alias]\n+\tif !ok {\n+\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\tif item.value == nil {\n+\t\treturn false, nil\n+\t}\n+\treturn true, item.value.Value()\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/state-impl.go.4\" with checksum 9873253d82d3cb4b45d9150cf98b5875\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype State struct {\r\n\titems        map[string]*queryStateItem\r\n\toperatorName string\r\n\twctx         IWorkpieceContext\r\n}\r\n\r\nfunc NewState() *State {\r\n\treturn \u0026State{\r\n\t\titems: make(map[string]*queryStateItem),\r\n\t}\r\n}\r\n\r\n// alias must be used before in MustExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) Get(alias string) (value interface{}) {\r\n\tvar ok bool\r\n\tvar item *queryStateItem\r\n\tif item, ok = s.items[alias]; !ok {\r\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\treturn item.value.Value()\r\n}\r\n\r\n// alias must be used before in CanExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n\titem, ok := s.items[alias]\r\n\tif !ok {\r\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\treturn false, nil\r\n\t}\r\n\treturn true, item.value.Value()\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype State struct {\n\titems        map[string]*queryStateItem\n\toperatorName string\n\twctx         IWorkpieceContext\n}\n\nfunc NewState() *State {\n\treturn \u0026State{\n\t\titems: make(map[string]*queryStateItem),\n\t}\n}\n\n// alias must be used before in MustExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) Get(alias string) (value interface{}) {\n\tvar ok bool\n\tvar item *queryStateItem\n\tif item, ok = s.items[alias]; !ok {\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\n\t}\n\tif item.value == nil {\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\n\t}\n\treturn item.value.Value()\n}\n\n// alias must be used before in CanExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n\titem, ok := s.items[alias]\n\tif !ok {\n\t\t_, _, _, _ = pipelinePanic, alias, s.operatorName, s.wctx\n\t}\n\tif item.value == nil {\n\t\treturn false, nil\n\t}\n\treturn true, item.value.Value()\n}\n","originalFilePath":"state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,44 +1,44 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type State struct {\r\n-\titems        map[string]*queryStateItem\r\n-\toperatorName string\r\n-\twctx         IWorkpieceContext\r\n-}\r\n-\r\n-func NewState() *State {\r\n-\treturn \u0026State{\r\n-\t\titems: make(map[string]*queryStateItem),\r\n-\t}\r\n-}\r\n-\r\n-// alias must be used before in MustExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) Get(alias string) (value interface{}) {\r\n-\tvar ok bool\r\n-\tvar item *queryStateItem\r\n-\tif item, ok = s.items[alias]; !ok {\r\n-\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\treturn item.value.Value()\r\n-}\r\n-\r\n-// alias must be used before in CanExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n-\titem, ok := s.items[alias]\r\n-\tif !ok {\r\n-\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\treturn false, nil\r\n-\t}\r\n-\treturn true, item.value.Value()\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type State struct {\n+\titems        map[string]*queryStateItem\n+\toperatorName string\n+\twctx         IWorkpieceContext\n+}\n+\n+func NewState() *State {\n+\treturn \u0026State{\n+\t\titems: make(map[string]*queryStateItem),\n+\t}\n+}\n+\n+// alias must be used before in MustExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) Get(alias string) (value interface{}) {\n+\tvar ok bool\n+\tvar item *queryStateItem\n+\tif item, ok = s.items[alias]; !ok {\n+\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\tif item.value == nil {\n+\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\treturn item.value.Value()\n+}\n+\n+// alias must be used before in CanExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n+\titem, ok := s.items[alias]\n+\tif !ok {\n+\t\t_, _, _, _ = pipelinePanic, alias, s.operatorName, s.wctx\n+\t}\n+\tif item.value == nil {\n+\t\treturn false, nil\n+\t}\n+\treturn true, item.value.Value()\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/state-impl.go.5\" with checksum 41fa258948db00b5590abe8b936fec66\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\ntype State struct {\r\n\titems        map[string]*queryStateItem\r\n\toperatorName string\r\n\twctx         IWorkpieceContext\r\n}\r\n\r\nfunc NewState() *State {\r\n\treturn \u0026State{\r\n\t\titems: make(map[string]*queryStateItem),\r\n\t}\r\n}\r\n\r\n// alias must be used before in MustExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) Get(alias string) (value interface{}) {\r\n\tvar ok bool\r\n\tvar item *queryStateItem\r\n\tif item, ok = s.items[alias]; !ok {\r\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\treturn item.value.Value()\r\n}\r\n\r\n// alias must be used before in CanExist\r\n// We do not know a good way to restore from this error, so panic() will be called\r\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n\titem, ok := s.items[alias]\r\n\tif !ok {\r\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n\t}\r\n\tif item.value == nil {\r\n\t\treturn false, nil\r\n\t}\r\n\treturn true, item.value.Value()\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\ntype State struct {\n\titems        map[string]*queryStateItem\n\toperatorName string\n\twctx         IWorkpieceContext\n}\n\nfunc NewState() *State {\n\treturn \u0026State{\n\t\titems: make(map[string]*queryStateItem),\n\t}\n}\n\n// alias must be used before in MustExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) Get(alias string) (value interface{}) {\n\tvar ok bool\n\tvar item *queryStateItem\n\tif item, ok = s.items[alias]; !ok {\n\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\n\t}\n\tif item.value == nil {\n\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\n\t}\n\treturn item.value.Value()\n}\n\n// alias must be used before in CanExist\n// We do not know a good way to restore from this error, so panic() will be called\nfunc (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n\titem, ok := s.items[alias]\n\tif !ok {\n\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\n\t}\n\tif item.value == nil {\n\n\t}\n\treturn true, item.value.Value()\n}\n","originalFilePath":"state-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,44 +1,44 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-type State struct {\r\n-\titems        map[string]*queryStateItem\r\n-\toperatorName string\r\n-\twctx         IWorkpieceContext\r\n-}\r\n-\r\n-func NewState() *State {\r\n-\treturn \u0026State{\r\n-\t\titems: make(map[string]*queryStateItem),\r\n-\t}\r\n-}\r\n-\r\n-// alias must be used before in MustExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) Get(alias string) (value interface{}) {\r\n-\tvar ok bool\r\n-\tvar item *queryStateItem\r\n-\tif item, ok = s.items[alias]; !ok {\r\n-\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\treturn item.value.Value()\r\n-}\r\n-\r\n-// alias must be used before in CanExist\r\n-// We do not know a good way to restore from this error, so panic() will be called\r\n-func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\r\n-\titem, ok := s.items[alias]\r\n-\tif !ok {\r\n-\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\r\n-\t}\r\n-\tif item.value == nil {\r\n-\t\treturn false, nil\r\n-\t}\r\n-\treturn true, item.value.Value()\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+type State struct {\n+\titems        map[string]*queryStateItem\n+\toperatorName string\n+\twctx         IWorkpieceContext\n+}\n+\n+func NewState() *State {\n+\treturn \u0026State{\n+\t\titems: make(map[string]*queryStateItem),\n+\t}\n+}\n+\n+// alias must be used before in MustExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) Get(alias string) (value interface{}) {\n+\tvar ok bool\n+\tvar item *queryStateItem\n+\tif item, ok = s.items[alias]; !ok {\n+\t\tpipelinePanic(\"state.Get for non-queried alias: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\tif item.value == nil {\n+\t\tpipelinePanic(\"state.Get for non-existing item: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\treturn item.value.Value()\n+}\n+\n+// alias must be used before in CanExist\n+// We do not know a good way to restore from this error, so panic() will be called\n+func (s *State) GetIfExists(alias string) (ok bool, value interface{}) {\n+\titem, ok := s.items[alias]\n+\tif !ok {\n+\t\tpipelinePanic(\"state.GetIfExists for non-queried alias: \"+alias, s.operatorName, s.wctx)\n+\t}\n+\tif item.value == nil {\n+\n+\t}\n+\treturn true, item.value.Value()\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/state-impl.go.6\" with checksum ceeb9f79e8602d1a17975f8b71ab4881\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\t_ = err\n\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\tbranch(switchOperator)\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,57 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\t_ = err\n+\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(switchOperator)\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.0\" with checksum 34e9860a8f0969ea2998aa43e5e04cfe\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\tbranch(switchOperator)\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,56 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(switchOperator)\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.1\" with checksum 3252fd798ce1e46153c969dd37a769f0\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbreak\n\t\tbranch.Close()\n\t}\n\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\tbranch(switchOperator)\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,58 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbreak\n+\t\tbranch.Close()\n+\t}\n+\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(switchOperator)\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.2\" with checksum 247e692c787db29f01387e972006fd1c\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\tbreak\n\t\tbranch(switchOperator)\n\t}\n\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,58 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\tbreak\n+\t\tbranch(switchOperator)\n+\t}\n+\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.3\" with checksum 78bc90cd001ddaeec861516ff8fd240f\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\t_, _, _, _ = s.currentBranchName, err, s.switchLogic.Switch, work\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\tbranch(switchOperator)\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,56 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\t_, _, _, _ = s.currentBranchName, err, s.switchLogic.Switch, work\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(switchOperator)\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.4\" with checksum 609a03cf6d18c7abedf4ed5f851e3802\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\t_ = branch.Close\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\tbranch(switchOperator)\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,56 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\t_ = branch.Close\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\tbranch(switchOperator)\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.5\" with checksum 49727b9aa149077c7dffde7779fde717\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\t_, _ = branch, switchOperator\n\n\tfor _, branch := range branches {\n\t\tbranch(switchOperator)\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,57 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\t_, _ = branch, switchOperator\n+\n+\tfor _, branch := range branches {\n+\t\tbranch(switchOperator)\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.6\" with checksum ee3df5b80f27b6d474b3a2328b3e402c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport \"context\"\r\n\r\ntype switchOperator struct {\r\n\tswitchLogic       ISwitch\r\n\tbranches          map[string]ISyncOperator\r\n\tcurrentBranchName string\r\n}\r\n\r\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn s.branches[s.currentBranchName].Prepare(work)\r\n}\r\n\r\nfunc (s switchOperator) Close() {\r\n\tfor _, branch := range s.branches {\r\n\t\tbranch.Close()\r\n\t}\r\n}\r\n\r\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n}\r\n\r\ntype SwitchOperatorOptionFunc func(*switchOperator)\r\n\r\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n\tif switchLogic == nil {\r\n\t\tpanic(\"switch must be not nil\")\r\n\t}\r\n\tswitchOperator := \u0026switchOperator{\r\n\t\tswitchLogic: switchLogic,\r\n\t\tbranches:    make(map[string]ISyncOperator),\r\n\t}\r\n\tbranch(switchOperator)\r\n\tfor _, branch := range branches {\r\n\t\tbranch(switchOperator)\r\n\t}\r\n\treturn switchOperator\r\n}\r\n\r\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n\treturn func(switchOperator *switchOperator) {\r\n\t\tswitchOperator.branches[name] = operator\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n */\n\npackage pipeline\n\nimport \"context\"\n\ntype switchOperator struct {\n\tswitchLogic       ISwitch\n\tbranches          map[string]ISyncOperator\n\tcurrentBranchName string\n}\n\nfunc (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n\ts.currentBranchName, err = s.switchLogic.Switch(work)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.branches[s.currentBranchName].Prepare(work)\n}\n\nfunc (s switchOperator) Close() {\n\tfor _, branch := range s.branches {\n\t\tbranch.Close()\n\t}\n}\n\nfunc (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n}\n\ntype SwitchOperatorOptionFunc func(*switchOperator)\n\nfunc SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n\tif switchLogic == nil {\n\t\tpanic(\"switch must be not nil\")\n\t}\n\tswitchOperator := \u0026switchOperator{\n\t\tswitchLogic: switchLogic,\n\t\tbranches:    make(map[string]ISyncOperator),\n\t}\n\tbranch(switchOperator)\n\tfor _, branch := range branches {\n\t\t_, _ = branch, switchOperator\n\n\t}\n\treturn switchOperator\n}\n\nfunc SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n\treturn func(switchOperator *switchOperator) {\n\t\tswitchOperator.branches[name] = operator\n\t}\n}\n","originalFilePath":"switch-operator-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,56 +1,57 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import \"context\"\r\n-\r\n-type switchOperator struct {\r\n-\tswitchLogic       ISwitch\r\n-\tbranches          map[string]ISyncOperator\r\n-\tcurrentBranchName string\r\n-}\r\n-\r\n-func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\r\n-\ts.currentBranchName, err = s.switchLogic.Switch(work)\r\n-\tif err != nil {\r\n-\t\treturn nil, err\r\n-\t}\r\n-\treturn s.branches[s.currentBranchName].Prepare(work)\r\n-}\r\n-\r\n-func (s switchOperator) Close() {\r\n-\tfor _, branch := range s.branches {\r\n-\t\tbranch.Close()\r\n-\t}\r\n-}\r\n-\r\n-func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\r\n-\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\r\n-}\r\n-\r\n-type SwitchOperatorOptionFunc func(*switchOperator)\r\n-\r\n-func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\r\n-\tif switchLogic == nil {\r\n-\t\tpanic(\"switch must be not nil\")\r\n-\t}\r\n-\tswitchOperator := \u0026switchOperator{\r\n-\t\tswitchLogic: switchLogic,\r\n-\t\tbranches:    make(map[string]ISyncOperator),\r\n-\t}\r\n-\tbranch(switchOperator)\r\n-\tfor _, branch := range branches {\r\n-\t\tbranch(switchOperator)\r\n-\t}\r\n-\treturn switchOperator\r\n-}\r\n-\r\n-func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\r\n-\treturn func(switchOperator *switchOperator) {\r\n-\t\tswitchOperator.branches[name] = operator\r\n-\t}\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+ */\n+\n+package pipeline\n+\n+import \"context\"\n+\n+type switchOperator struct {\n+\tswitchLogic       ISwitch\n+\tbranches          map[string]ISyncOperator\n+\tcurrentBranchName string\n+}\n+\n+func (s *switchOperator) Prepare(work interface{}) (queryState OpFuncQueryState, err error) {\n+\ts.currentBranchName, err = s.switchLogic.Switch(work)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn s.branches[s.currentBranchName].Prepare(work)\n+}\n+\n+func (s switchOperator) Close() {\n+\tfor _, branch := range s.branches {\n+\t\tbranch.Close()\n+\t}\n+}\n+\n+func (s switchOperator) DoSync(ctx context.Context, work interface{}, state IState) (err error) {\n+\treturn s.branches[s.currentBranchName].DoSync(ctx, work, state)\n+}\n+\n+type SwitchOperatorOptionFunc func(*switchOperator)\n+\n+func SwitchOperator(switchLogic ISwitch, branch SwitchOperatorOptionFunc, branches ...SwitchOperatorOptionFunc) ISyncOperator {\n+\tif switchLogic == nil {\n+\t\tpanic(\"switch must be not nil\")\n+\t}\n+\tswitchOperator := \u0026switchOperator{\n+\t\tswitchLogic: switchLogic,\n+\t\tbranches:    make(map[string]ISyncOperator),\n+\t}\n+\tbranch(switchOperator)\n+\tfor _, branch := range branches {\n+\t\t_, _ = branch, switchOperator\n+\n+\t}\n+\treturn switchOperator\n+}\n+\n+func SwitchBranch(name string, operator ISyncOperator) SwitchOperatorOptionFunc {\n+\treturn func(switchOperator *switchOperator) {\n+\t\tswitchOperator.branches[name] = operator\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/switch-operator-impl.go.8\" with checksum 72c660fc74bea716cf400b53ae65fc95\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\t_ = p.ctx.Err\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\t_ = p.ctx.Err\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.0\" with checksum 6109b863d5b1153ee7e4d76627c607cf\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\t_ = err\n\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,91 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\t_ = err\n+\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.1\" with checksum 0ca8f66557f8a8b9a9ea3fd4b9ea12aa\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.2\" with checksum b53431de3449f2ea25546ebb44d0fa2e\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tbreak\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,92 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tbreak\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.3\" with checksum f3eec177b9d37ea4175d6ae5bce2fff5\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\tbreak\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,92 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\tbreak\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.4\" with checksum ac262f0075aee8b693f7d0cc0f5597b1\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tbreak\n\t\tgo puller_sync(op)\n\t}\n\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,92 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tbreak\n+\t\tgo puller_sync(op)\n+\t}\n+\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.5\" with checksum 5694dfca5d6a437a2665dd5267e382df\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 0),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 0),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.8\" with checksum a8284db0611772fb5e3feec5a71274c9\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 2),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 2),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.11\" with checksum b52b06987006d79177d05ff5700444b2\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[1] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[1] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.12\" with checksum c869543c5ae6d0b8d6b88bfc48919b86\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\t_, _ = first.Stdin, pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\t_, _ = first.Stdin, pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.15\" with checksum 1ed6bee2e07752427b18cc5e42005861\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\t_, _ = pstruct.WriteString, first.String\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\t_, _ = pstruct.WriteString, first.String\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.17\" with checksum 545693c132bdc79f47d19c584e365bb4\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\t_, _ = pipeline.stdout, last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\t_, _ = pipeline.stdout, last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.18\" with checksum e2a595697e7b9015a34252f111d4ec83\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\t_, _, _, _ = pipeline.wctx, NewWorkpieceContext, name, pstruct.String\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\t_, _, _, _ = pipeline.wctx, NewWorkpieceContext, name, pstruct.String\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.19\" with checksum 698e828e9a618e3cb694db37817aad08\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\t_, _ = next.Stdin, last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\t_, _ = next.Stdin, last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.21\" with checksum 75a295243c782b3c0b890873e67a1e1c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\t_, _ = last, next\n\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,91 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\t_, _ = last, next\n+\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.23\" with checksum 067bc90691a1865d8aad07a0a939cac8\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\t_ = pstruct.WriteString\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\t_ = pstruct.WriteString\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.24\" with checksum 537ca92768f545a50826deab6e206ad4\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\t_, _ = pstruct.WriteString, next.String\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\t_, _ = pstruct.WriteString, next.String\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.25\" with checksum e3f20d26215b4882c910afe98592c82c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\t_, _ = op.storages, storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\t_, _ = op.storages, storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.26\" with checksum 1038adc5bc686b0487a5cbd8b8fd68fa\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\t_, _ = op.ctx, ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\t_, _ = op.ctx, ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.27\" with checksum fc274670b5d9e350aca2244710a0b93f\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\t_, _ = op.wctx, pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\tclose(p.stdin)\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\t_, _ = op.wctx, pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\tclose(p.stdin)\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.28\" with checksum 3eb2f7c574c68d5a94d662c1f552a8f2\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"strings\"\r\n)\r\n\r\ntype SyncPipeline struct {\r\n\tname string\r\n\twctx IWorkpieceContext\r\n\tctx  context.Context\r\n\t// stdin created by pipeline\r\n\tstdin chan interface{}\r\n\t// stdout points to the Stdout of the last operator\r\n\tstdout    chan interface{}\r\n\toperators []*WiredOperator\r\n}\r\n\r\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n\tvar pstruct strings.Builder\r\n\tpipeline := \u0026SyncPipeline{\r\n\t\tctx:       ctx,\r\n\t\tname:      name,\r\n\t\tstdin:     make(chan interface{}, 1),\r\n\t\toperators: make([]*WiredOperator, 1),\r\n\t}\r\n\tcheckSyncOperator(first)\r\n\tpipeline.operators[0] = first\r\n\tfirst.Stdin = pipeline.stdin\r\n\tpipeline.stdout = first.Stdout\r\n\tpstruct.WriteString(first.String())\r\n\tlast := first\r\n\r\n\tfor _, next := range others {\r\n\t\tcheckSyncOperator(next)\r\n\t\tnext.Stdin = last.Stdout\r\n\t\tpipeline.operators = append(pipeline.operators, next)\r\n\t\tlast = next\r\n\t\tpstruct.WriteString(\", \")\r\n\t\tpstruct.WriteString(next.String())\r\n\t}\r\n\tpipeline.stdout = last.Stdout\r\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n\r\n\tfor _, op := range pipeline.operators {\r\n\t\top.storages = storages\r\n\t\top.ctx = ctx\r\n\t\top.wctx = pipeline.wctx\r\n\t}\r\n\tfor _, op := range pipeline.operators {\r\n\t\tgo puller_sync(op)\r\n\t}\r\n\treturn pipeline\r\n}\r\n\r\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n\treturn nil, nil\r\n}\r\n\r\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n\treturn p.SendSync(work)\r\n}\r\n\r\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n\tif p.ctx.Err() != nil {\r\n\t\treturn p.ctx.Err()\r\n\t}\r\n\tp.stdin \u003c- work\r\n\toutWork := \u003c-p.stdout\r\n\tif err, ok := outWork.(error); ok {\r\n\t\treturn err\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (p SyncPipeline) Close() {\r\n\tclose(p.stdin)\r\n\tfor range p.stdout {\r\n\t}\r\n}\r\n\r\nfunc checkSyncOperator(wo *WiredOperator) {\r\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n\t\tpanic(\"sync pipeline only supports sync operators\")\r\n\t}\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\ntype SyncPipeline struct {\n\tname string\n\twctx IWorkpieceContext\n\tctx  context.Context\n\t// stdin created by pipeline\n\tstdin chan interface{}\n\t// stdout points to the Stdout of the last operator\n\tstdout    chan interface{}\n\toperators []*WiredOperator\n}\n\nfunc NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n\tvar pstruct strings.Builder\n\tpipeline := \u0026SyncPipeline{\n\t\tctx:       ctx,\n\t\tname:      name,\n\t\tstdin:     make(chan interface{}, 1),\n\t\toperators: make([]*WiredOperator, 1),\n\t}\n\tcheckSyncOperator(first)\n\tpipeline.operators[0] = first\n\tfirst.Stdin = pipeline.stdin\n\tpipeline.stdout = first.Stdout\n\tpstruct.WriteString(first.String())\n\tlast := first\n\n\tfor _, next := range others {\n\t\tcheckSyncOperator(next)\n\t\tnext.Stdin = last.Stdout\n\t\tpipeline.operators = append(pipeline.operators, next)\n\t\tlast = next\n\t\tpstruct.WriteString(\", \")\n\t\tpstruct.WriteString(next.String())\n\t}\n\tpipeline.stdout = last.Stdout\n\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n\n\tfor _, op := range pipeline.operators {\n\t\top.storages = storages\n\t\top.ctx = ctx\n\t\top.wctx = pipeline.wctx\n\t}\n\tfor _, op := range pipeline.operators {\n\t\tgo puller_sync(op)\n\t}\n\treturn pipeline\n}\n\nfunc (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n\treturn nil, nil\n}\n\nfunc (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n\treturn p.SendSync(work)\n}\n\nfunc (p SyncPipeline) SendSync(work interface{}) (err error) {\n\tif p.ctx.Err() != nil {\n\t\treturn p.ctx.Err()\n\t}\n\tp.stdin \u003c- work\n\toutWork := \u003c-p.stdout\n\tif err, ok := outWork.(error); ok {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (p SyncPipeline) Close() {\n\t_ = p.stdin\n\tfor range p.stdout {\n\t}\n}\n\nfunc checkSyncOperator(wo *WiredOperator) {\n\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n\t\tpanic(\"sync pipeline only supports sync operators\")\n\t}\n}\n","originalFilePath":"sync-pipeline-impl.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,90 +1,90 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"strings\"\r\n-)\r\n-\r\n-type SyncPipeline struct {\r\n-\tname string\r\n-\twctx IWorkpieceContext\r\n-\tctx  context.Context\r\n-\t// stdin created by pipeline\r\n-\tstdin chan interface{}\r\n-\t// stdout points to the Stdout of the last operator\r\n-\tstdout    chan interface{}\r\n-\toperators []*WiredOperator\r\n-}\r\n-\r\n-func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\r\n-\tvar pstruct strings.Builder\r\n-\tpipeline := \u0026SyncPipeline{\r\n-\t\tctx:       ctx,\r\n-\t\tname:      name,\r\n-\t\tstdin:     make(chan interface{}, 1),\r\n-\t\toperators: make([]*WiredOperator, 1),\r\n-\t}\r\n-\tcheckSyncOperator(first)\r\n-\tpipeline.operators[0] = first\r\n-\tfirst.Stdin = pipeline.stdin\r\n-\tpipeline.stdout = first.Stdout\r\n-\tpstruct.WriteString(first.String())\r\n-\tlast := first\r\n-\r\n-\tfor _, next := range others {\r\n-\t\tcheckSyncOperator(next)\r\n-\t\tnext.Stdin = last.Stdout\r\n-\t\tpipeline.operators = append(pipeline.operators, next)\r\n-\t\tlast = next\r\n-\t\tpstruct.WriteString(\", \")\r\n-\t\tpstruct.WriteString(next.String())\r\n-\t}\r\n-\tpipeline.stdout = last.Stdout\r\n-\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\r\n-\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\top.storages = storages\r\n-\t\top.ctx = ctx\r\n-\t\top.wctx = pipeline.wctx\r\n-\t}\r\n-\tfor _, op := range pipeline.operators {\r\n-\t\tgo puller_sync(op)\r\n-\t}\r\n-\treturn pipeline\r\n-}\r\n-\r\n-func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\r\n-\treturn nil, nil\r\n-}\r\n-\r\n-func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\r\n-\treturn p.SendSync(work)\r\n-}\r\n-\r\n-func (p SyncPipeline) SendSync(work interface{}) (err error) {\r\n-\tif p.ctx.Err() != nil {\r\n-\t\treturn p.ctx.Err()\r\n-\t}\r\n-\tp.stdin \u003c- work\r\n-\toutWork := \u003c-p.stdout\r\n-\tif err, ok := outWork.(error); ok {\r\n-\t\treturn err\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (p SyncPipeline) Close() {\r\n-\tclose(p.stdin)\r\n-\tfor range p.stdout {\r\n-\t}\r\n-}\r\n-\r\n-func checkSyncOperator(wo *WiredOperator) {\r\n-\tif _, ok := wo.Operator.(ISyncOperator); !ok {\r\n-\t\tpanic(\"sync pipeline only supports sync operators\")\r\n-\t}\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"strings\"\n+)\n+\n+type SyncPipeline struct {\n+\tname string\n+\twctx IWorkpieceContext\n+\tctx  context.Context\n+\t// stdin created by pipeline\n+\tstdin chan interface{}\n+\t// stdout points to the Stdout of the last operator\n+\tstdout    chan interface{}\n+\toperators []*WiredOperator\n+}\n+\n+func NewSyncPipeline(ctx context.Context, name string, storages IStorages, first *WiredOperator, others ...*WiredOperator) ISyncPipeline {\n+\tvar pstruct strings.Builder\n+\tpipeline := \u0026SyncPipeline{\n+\t\tctx:       ctx,\n+\t\tname:      name,\n+\t\tstdin:     make(chan interface{}, 1),\n+\t\toperators: make([]*WiredOperator, 1),\n+\t}\n+\tcheckSyncOperator(first)\n+\tpipeline.operators[0] = first\n+\tfirst.Stdin = pipeline.stdin\n+\tpipeline.stdout = first.Stdout\n+\tpstruct.WriteString(first.String())\n+\tlast := first\n+\n+\tfor _, next := range others {\n+\t\tcheckSyncOperator(next)\n+\t\tnext.Stdin = last.Stdout\n+\t\tpipeline.operators = append(pipeline.operators, next)\n+\t\tlast = next\n+\t\tpstruct.WriteString(\", \")\n+\t\tpstruct.WriteString(next.String())\n+\t}\n+\tpipeline.stdout = last.Stdout\n+\tpipeline.wctx = NewWorkpieceContext(name, pstruct.String())\n+\n+\tfor _, op := range pipeline.operators {\n+\t\top.storages = storages\n+\t\top.ctx = ctx\n+\t\top.wctx = pipeline.wctx\n+\t}\n+\tfor _, op := range pipeline.operators {\n+\t\tgo puller_sync(op)\n+\t}\n+\treturn pipeline\n+}\n+\n+func (p SyncPipeline) Prepare(_ interface{}) (queryState OpFuncQueryState, err error) {\n+\treturn nil, nil\n+}\n+\n+func (p SyncPipeline) DoSync(_ context.Context, work interface{}, _ IState) (err error) {\n+\treturn p.SendSync(work)\n+}\n+\n+func (p SyncPipeline) SendSync(work interface{}) (err error) {\n+\tif p.ctx.Err() != nil {\n+\t\treturn p.ctx.Err()\n+\t}\n+\tp.stdin \u003c- work\n+\toutWork := \u003c-p.stdout\n+\tif err, ok := outWork.(error); ok {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (p SyncPipeline) Close() {\n+\t_ = p.stdin\n+\tfor range p.stdout {\n+\t}\n+}\n+\n+func checkSyncOperator(wo *WiredOperator) {\n+\tif _, ok := wo.Operator.(ISyncOperator); !ok {\n+\t\tpanic(\"sync pipeline only supports sync operators\")\n+\t}\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync-pipeline-impl.go.29\" with checksum 843d2d1815a27a6efec7ee606f676757\n"},{"mutator":{"mutatorName":"branch/else","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_, _ = wo.Stdout, err\n\t\t\t}\n\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t_, _ = wo.Stdout, err\n+\t\t\t}\n+\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.0\" with checksum f039aa73a0fc22193b15cccffbf54e0b\n"},{"mutator":{"mutatorName":"branch/else","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\t_, _ = wo.Stdout, work\n\t\t}\n\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,49 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\t_, _ = wo.Stdout, work\n+\t\t}\n+\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.1\" with checksum 5714c3a6ef5149784e2f81d3139f3431\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\t_, _, _ = pipelinePanic, wo.name, wo.wctx\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\t_, _, _ = pipelinePanic, wo.name, wo.wctx\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.2\" with checksum 08c546fbcdb39346c677a7d8ab9ffbdc\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\t_, _, _, _, _, _, _ = wo.Stdout, wo.NewError, fmt.Errorf, newerr, err.Error, err.GetWork, placeCatchOnErr\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\t_, _, _, _, _, _, _ = wo.Stdout, wo.NewError, fmt.Errorf, newerr, err.Error, err.GetWork, placeCatchOnErr\n+\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.5\" with checksum 9f4d12c9d36eeddba01f7369beeb30ab\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\t_, _ = wo.Stdout, err\n\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\t_, _ = wo.Stdout, err\n+\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.6\" with checksum 7f2c9384fd39fe6c021b46389000a56d\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\t_, _ = wo.Stdout, err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\t_, _ = wo.Stdout, err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.7\" with checksum fc602ca79679983b20482567b5771510\n"},{"mutator":{"mutatorName":"loop/break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tbreak\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tbreak\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.10\" with checksum ef3c8dec1d9f8f1b03c3c7a5ed47e58d\n"},{"mutator":{"mutatorName":"loop/range_break","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tbreak\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,50 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tbreak\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.11\" with checksum 029510abb1550da32dd54addc8e7ae84\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\t_ = wo.Operator.Close\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\t_ = wo.Operator.Close\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.12\" with checksum d2d01072e03e5159bb53de44c11f2e86\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\t_ = wo.Stdout\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\t_ = wo.Stdout\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.13\" with checksum 51705b4f48ff168d63669ed1f7550e5c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twork = err.GetWork() // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\t\t_, _, _, _, _ = err, wo.doSync, wo.ctx, work, state\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,47 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\twork = err.GetWork() // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\t\t_, _, _, _, _ = err, wo.doSync, wo.ctx, work, state\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.14\" with checksum 5f5201ff7f3c8bfb688488195e8960ae\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n*\r\n* Copyright (c) 2021-present unTill Pro, Ltd.\r\n*\r\n* @author Michael Saigachenko\r\n*\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"fmt\"\r\n)\r\n\r\nfunc puller_sync(wo *WiredOperator) {\r\n\tfor work := range wo.Stdin {\r\n\t\tif work == nil {\r\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n\t\t}\r\n\t\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\two.Stdout \u003c- err\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\twork = err.GetWork() // restore from error\r\n\t\t}\r\n\r\n\t\tstate, err := wo.prepare(work)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\terr = wo.doSync(wo.ctx, work, state)\r\n\t\tif err != nil {\r\n\t\t\two.Stdout \u003c- err\r\n\t\t} else {\r\n\t\t\two.Stdout \u003c- work\r\n\t\t}\r\n\t}\r\n\two.Operator.Close()\r\n\tclose(wo.Stdout)\r\n}\r\n","mutatedSourceCode":"/*\n*\n* Copyright (c) 2021-present unTill Pro, Ltd.\n*\n* @author Michael Saigachenko\n*\n */\n\npackage pipeline\n\nimport (\n\t\"fmt\"\n)\n\nfunc puller_sync(wo *WiredOperator) {\n\tfor work := range wo.Stdin {\n\t\tif work == nil {\n\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n\t\t}\n\t\tif err, ok := work.(IErrorPipeline); ok {\n\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\two.Stdout \u003c- err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, _ = work, err.GetWork // restore from error\n\t\t}\n\n\t\tstate, err := wo.prepare(work)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t\tcontinue\n\t\t}\n\n\t\terr = wo.doSync(wo.ctx, work, state)\n\t\tif err != nil {\n\t\t\two.Stdout \u003c- err\n\t\t} else {\n\t\t\two.Stdout \u003c- work\n\t\t}\n\t}\n\two.Operator.Close()\n\tclose(wo.Stdout)\n}\n","originalFilePath":"sync.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,48 +1,48 @@\n-/*\r\n-*\r\n-* Copyright (c) 2021-present unTill Pro, Ltd.\r\n-*\r\n-* @author Michael Saigachenko\r\n-*\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"fmt\"\r\n-)\r\n-\r\n-func puller_sync(wo *WiredOperator) {\r\n-\tfor work := range wo.Stdin {\r\n-\t\tif work == nil {\r\n-\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\r\n-\t\t}\r\n-\t\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\r\n-\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\r\n-\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\r\n-\t\t\t\t\tcontinue\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\two.Stdout \u003c- err\r\n-\t\t\t\tcontinue\r\n-\t\t\t}\r\n-\t\t\twork = err.GetWork() // restore from error\r\n-\t\t}\r\n-\r\n-\t\tstate, err := wo.prepare(work)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t\tcontinue\r\n-\t\t}\r\n-\r\n-\t\terr = wo.doSync(wo.ctx, work, state)\r\n-\t\tif err != nil {\r\n-\t\t\two.Stdout \u003c- err\r\n-\t\t} else {\r\n-\t\t\two.Stdout \u003c- work\r\n-\t\t}\r\n-\t}\r\n-\two.Operator.Close()\r\n-\tclose(wo.Stdout)\r\n-}\r\n+/*\n+*\n+* Copyright (c) 2021-present unTill Pro, Ltd.\n+*\n+* @author Michael Saigachenko\n+*\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func puller_sync(wo *WiredOperator) {\n+\tfor work := range wo.Stdin {\n+\t\tif work == nil {\n+\t\t\tpipelinePanic(\"nil in puller_sync stdin\", wo.name, wo.wctx)\n+\t\t}\n+\t\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t\tif catch, ok := wo.Operator.(ICatch); ok {\n+\t\t\t\tif newerr := catch.OnErr(err, err.GetWork(), wo.wctx); newerr != nil {\n+\t\t\t\t\two.Stdout \u003c- wo.NewError(fmt.Errorf(\"nested error '%w' while handling '%s'\", newerr, err.Error()), err.GetWork(), placeCatchOnErr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\two.Stdout \u003c- err\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t_, _ = work, err.GetWork // restore from error\n+\t\t}\n+\n+\t\tstate, err := wo.prepare(work)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = wo.doSync(wo.ctx, work, state)\n+\t\tif err != nil {\n+\t\t\two.Stdout \u003c- err\n+\t\t} else {\n+\t\t\two.Stdout \u003c- work\n+\t\t}\n+\t}\n+\two.Operator.Close()\n+\tclose(wo.Stdout)\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/sync.go.16\" with checksum e1c042e738110a5bf34c8aba7ca98c35\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\t_, _ = flush, flushIntvl\n\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,116 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\t_, _ = flush, flushIntvl\n+\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.1\" with checksum e889df79d401584a10772774ebc8b103\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\t_, _, _ = pipelinePanic, wo.name, wo.wctx\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\t_, _, _ = pipelinePanic, wo.name, wo.wctx\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.2\" with checksum ee22a7e2fbfa05f262eec6f0b2b8718c\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\t_, _, _, _ = wo.ctx, err, wo.Stdout, err\n\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,114 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t_, _, _, _ = wo.ctx, err, wo.Stdout, err\n+\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.3\" with checksum 25449ec0d961293037c025b550e69ec9\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\t_, _, _, _, _, _, _, _, _ = outWork, wo.NewError, e, work, placeDoAsyncOutWorkIsNil, // TODO: p_release(work)?\n\t\t\two.NewError, e, outWork, placeDoAsyncOutWorkNotNil\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,112 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\t_, _, _, _, _, _, _, _, _ = outWork, wo.NewError, e, work, placeDoAsyncOutWorkIsNil, // TODO: p_release(work)?\n+\t\t\two.NewError, e, outWork, placeDoAsyncOutWorkNotNil\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.4\" with checksum 554c68a11777c31949256fddf46e7eef\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\t_, _, _, _ = wo.NewError, e, work, placeDoAsyncOutWorkIsNil\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\t_, _, _, _ = wo.NewError, e, work, placeDoAsyncOutWorkIsNil\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.5\" with checksum 893ed5e73cb6d6ea8d550773c0a8cc5b\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\t_, _, _, _ = wo.NewError, e, work, placeDoSync\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\t_, _, _, _ = wo.NewError, e, work, placeDoSync\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.6\" with checksum 80425ae029d26ec29f35cd837aca259f\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n+\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.7\" with checksum faa6fbd7d9523ac6e95283a5e59f6690\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\t_, _, _, _, _, _, _, _, _, _, _, _, _, _ = state, e, Prepare, wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries, e, err, wo.NewError, e, work, placePrepare\n\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,112 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\t_, _, _, _, _, _, _, _, _, _, _, _, _, _ = state, e, Prepare, wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries, e, err, wo.NewError, e, work, placePrepare\n+\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.8\" with checksum 39a22ab4aca09b3528f504c55ef1c8c6\n"},{"mutator":{"mutatorName":"branch/if","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n+\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.9\" with checksum b330bcd2448fe2385478d5b018195cb5\n"},{"mutator":{"mutatorName":"expression/comparison","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e= 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e= 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.10\" with checksum d9029fa690913200923e1758927f656a\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn true \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn true \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.11\" with checksum db53ab5a28c0c01b590dab59e2f38fd1\n"},{"mutator":{"mutatorName":"expression/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 true\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 true\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.12\" with checksum d6bf3d2ad568bb8ac8f6a98e9992ad0c\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e -1 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e -1 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.13\" with checksum 5e8e08f8d7b4b36bd536363f9cff68f1\n"},{"mutator":{"mutatorName":"numbers/decrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 0),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 0),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.15\" with checksum bbd94495d8ecb78e7f47d4c00cf533c6\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 1 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 1 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.17\" with checksum 5d6871f55e5fb5b36019abfa4bdbd719\n"},{"mutator":{"mutatorName":"numbers/incrementer","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[1]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[1]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.18\" with checksum dfb5faa5aa5a587c4942cca0cbb0f6f4\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\t_, _ = wo.ctx, err\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\t_, _ = wo.ctx, err\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.23\" with checksum 34ea3d1e943dcf14f023ed32bef2b37c\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.25\" with checksum ff74b46bf644c5d9e0de469c84aad621\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\t_, _, _, _, _, _, _, _ = state, e, Prepare, wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries\n\t\tif e != nil {\n\t\t\terr = wo.NewError(e, work, placePrepare)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\t_, _, _, _, _, _, _, _ = state, e, Prepare, wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries\n+\t\tif e != nil {\n+\t\t\terr = wo.NewError(e, work, placePrepare)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.26\" with checksum 2005eefad278ee2c2482efb2292def29\n"},{"mutator":{"mutatorName":"statement/remove","originalSourceCode":"/*\r\n * Copyright (c) 2021-present unTill Pro, Ltd.\r\n */\r\n\r\npackage pipeline\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n)\r\n\r\ntype WiredOperator struct {\r\n\tname              string\r\n\twctx              IWorkpieceContext\r\n\tStdin             chan interface{} // Stdin is provided by the builder\r\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n\tOperator          IOperator\r\n\tFlushInterval     time.Duration\r\n\tstorages          IStorages\r\n\tctx               context.Context\r\n\terr               IErrorPipeline\r\n\tMaxPrepareQueries int\r\n}\r\n\r\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n\tvar flush time.Duration\r\n\tif len(flushIntvl) \u003e 0 {\r\n\t\tflush = flushIntvl[0]\r\n\t}\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tFlushInterval:     flush,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n\treturn \u0026WiredOperator{\r\n\t\tname:              name,\r\n\t\tStdin:             nil,\r\n\t\tStdout:            make(chan interface{}, 1),\r\n\t\tOperator:          op,\r\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n\t}\r\n}\r\n\r\nfunc (wo WiredOperator) isActive() bool {\r\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n}\r\n\r\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n\tif work == nil {\r\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n\t}\r\n\r\n\tif err, ok := work.(IErrorPipeline); ok {\r\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n\t\two.Stdout \u003c- err\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (wo WiredOperator) String() string {\r\n\treturn \"operator: \" + wo.name\r\n}\r\n\r\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n\tep := errPipeline{\r\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n\t\twork: work,\r\n\t}\r\n\two.err = \u0026ep\r\n\treturn \u0026ep\r\n}\r\n\r\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\tif outWork == nil {\r\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n\t\t}\r\n\t\t// TODO: p_release(work)?\r\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n\t}\r\n\treturn outWork, nil\r\n}\r\n\r\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n\tif e != nil {\r\n\t\treturn wo.NewError(e, work, placeDoSync)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n\tfQueryState, e := wo.Operator.Prepare(work)\r\n\tif e != nil {\r\n\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\treturn\r\n\t}\r\n\tif fQueryState != nil {\r\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n\t\tif e != nil {\r\n\t\t\terr = wo.NewError(e, work, placePrepare)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n","mutatedSourceCode":"/*\n * Copyright (c) 2021-present unTill Pro, Ltd.\n */\n\npackage pipeline\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype WiredOperator struct {\n\tname              string\n\twctx              IWorkpieceContext\n\tStdin             chan interface{} // Stdin is provided by the builder\n\tStdout            chan interface{} // Stdout is owned by WiredOperator\n\tOperator          IOperator\n\tFlushInterval     time.Duration\n\tstorages          IStorages\n\tctx               context.Context\n\terr               IErrorPipeline\n\tMaxPrepareQueries int\n}\n\nfunc WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n\tvar flush time.Duration\n\tif len(flushIntvl) \u003e 0 {\n\t\tflush = flushIntvl[0]\n\t}\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tFlushInterval:     flush,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n\treturn \u0026WiredOperator{\n\t\tname:              name,\n\t\tStdin:             nil,\n\t\tStdout:            make(chan interface{}, 1),\n\t\tOperator:          op,\n\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n\t}\n}\n\nfunc (wo WiredOperator) isActive() bool {\n\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n}\n\nfunc (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n\tif work == nil {\n\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n\t}\n\n\tif err, ok := work.(IErrorPipeline); ok {\n\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n\t\two.Stdout \u003c- err\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (wo WiredOperator) String() string {\n\treturn \"operator: \" + wo.name\n}\n\nfunc (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n\tep := errPipeline{\n\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n\t\twork: work,\n\t}\n\two.err = \u0026ep\n\treturn \u0026ep\n}\n\nfunc (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n\tif e != nil {\n\t\tif outWork == nil {\n\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n\t\t}\n\t\t// TODO: p_release(work)?\n\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n\t}\n\treturn outWork, nil\n}\n\nfunc (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n\tif e != nil {\n\t\treturn wo.NewError(e, work, placeDoSync)\n\t}\n\treturn nil\n}\n\nfunc (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n\tfQueryState, e := wo.Operator.Prepare(work)\n\tif e != nil {\n\t\terr = wo.NewError(e, work, placePrepare)\n\t\treturn\n\t}\n\tif fQueryState != nil {\n\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n\t\tif e != nil {\n\t\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n","originalFilePath":"wired-operator.go","originalStartLine":0},"diff":"--- Original\n+++ New\n@@ -1,115 +1,115 @@\n-/*\r\n- * Copyright (c) 2021-present unTill Pro, Ltd.\r\n- */\r\n-\r\n-package pipeline\r\n-\r\n-import (\r\n-\t\"context\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-)\r\n-\r\n-type WiredOperator struct {\r\n-\tname              string\r\n-\twctx              IWorkpieceContext\r\n-\tStdin             chan interface{} // Stdin is provided by the builder\r\n-\tStdout            chan interface{} // Stdout is owned by WiredOperator\r\n-\tOperator          IOperator\r\n-\tFlushInterval     time.Duration\r\n-\tstorages          IStorages\r\n-\tctx               context.Context\r\n-\terr               IErrorPipeline\r\n-\tMaxPrepareQueries int\r\n-}\r\n-\r\n-func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\r\n-\tvar flush time.Duration\r\n-\tif len(flushIntvl) \u003e 0 {\r\n-\t\tflush = flushIntvl[0]\r\n-\t}\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tFlushInterval:     flush,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\r\n-\treturn \u0026WiredOperator{\r\n-\t\tname:              name,\r\n-\t\tStdin:             nil,\r\n-\t\tStdout:            make(chan interface{}, 1),\r\n-\t\tOperator:          op,\r\n-\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\r\n-\t}\r\n-}\r\n-\r\n-func (wo WiredOperator) isActive() bool {\r\n-\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\r\n-}\r\n-\r\n-func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\r\n-\tif work == nil {\r\n-\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\r\n-\t}\r\n-\r\n-\tif err, ok := work.(IErrorPipeline); ok {\r\n-\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\r\n-\t\two.Stdout \u003c- err\r\n-\t\treturn true\r\n-\t}\r\n-\treturn false\r\n-}\r\n-\r\n-func (wo WiredOperator) String() string {\r\n-\treturn \"operator: \" + wo.name\r\n-}\r\n-\r\n-func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\r\n-\tep := errPipeline{\r\n-\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\r\n-\t\twork: work,\r\n-\t}\r\n-\two.err = \u0026ep\r\n-\treturn \u0026ep\r\n-}\r\n-\r\n-func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\r\n-\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\tif outWork == nil {\r\n-\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\r\n-\t\t}\r\n-\t\t// TODO: p_release(work)?\r\n-\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\r\n-\t}\r\n-\treturn outWork, nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\r\n-\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\r\n-\tif e != nil {\r\n-\t\treturn wo.NewError(e, work, placeDoSync)\r\n-\t}\r\n-\treturn nil\r\n-}\r\n-\r\n-func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\r\n-\tfQueryState, e := wo.Operator.Prepare(work)\r\n-\tif e != nil {\r\n-\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\treturn\r\n-\t}\r\n-\tif fQueryState != nil {\r\n-\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\r\n-\t\tif e != nil {\r\n-\t\t\terr = wo.NewError(e, work, placePrepare)\r\n-\t\t\treturn\r\n-\t\t}\r\n-\t}\r\n-\treturn\r\n-}\r\n+/*\n+ * Copyright (c) 2021-present unTill Pro, Ltd.\n+ */\n+\n+package pipeline\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+type WiredOperator struct {\n+\tname              string\n+\twctx              IWorkpieceContext\n+\tStdin             chan interface{} // Stdin is provided by the builder\n+\tStdout            chan interface{} // Stdout is owned by WiredOperator\n+\tOperator          IOperator\n+\tFlushInterval     time.Duration\n+\tstorages          IStorages\n+\tctx               context.Context\n+\terr               IErrorPipeline\n+\tMaxPrepareQueries int\n+}\n+\n+func WireAsyncOperator(name string, op IAsyncOperator, flushIntvl ...time.Duration) *WiredOperator {\n+\tvar flush time.Duration\n+\tif len(flushIntvl) \u003e 0 {\n+\t\tflush = flushIntvl[0]\n+\t}\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tFlushInterval:     flush,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func WireSyncOperator(name string, op ISyncOperator) *WiredOperator {\n+\treturn \u0026WiredOperator{\n+\t\tname:              name,\n+\t\tStdin:             nil,\n+\t\tStdout:            make(chan interface{}, 1),\n+\t\tOperator:          op,\n+\t\tMaxPrepareQueries: DefaultMaxPrepareQueries,\n+\t}\n+}\n+\n+func (wo WiredOperator) isActive() bool {\n+\treturn wo.ctx.Err() == nil \u0026\u0026 wo.err == nil\n+}\n+\n+func (wo WiredOperator) forwardIfErrorAsync(work IWorkpiece) bool {\n+\tif work == nil {\n+\t\tpipelinePanic(\"nil in puller_async stdin\", wo.name, wo.wctx)\n+\t}\n+\n+\tif err, ok := work.(IErrorPipeline); ok {\n+\t\two.Operator.(IAsyncOperator).OnError(wo.ctx, err)\n+\t\two.Stdout \u003c- err\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (wo WiredOperator) String() string {\n+\treturn \"operator: \" + wo.name\n+}\n+\n+func (wo *WiredOperator) NewError(err error, work interface{}, place string) IErrorPipeline {\n+\tep := errPipeline{\n+\t\terr:  fmt.Errorf(\"[%s/%s] %w\", wo.name, place, err),\n+\t\twork: work,\n+\t}\n+\two.err = \u0026ep\n+\treturn \u0026ep\n+}\n+\n+func (wo *WiredOperator) doAsync(work IWorkpiece, state *State) (IWorkpiece, IErrorPipeline) {\n+\toutWork, e := wo.Operator.(IAsyncOperator).DoAsync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\tif outWork == nil {\n+\t\t\treturn nil, wo.NewError(e, work, placeDoAsyncOutWorkIsNil)\n+\t\t}\n+\t\t// TODO: p_release(work)?\n+\t\treturn nil, wo.NewError(e, outWork, placeDoAsyncOutWorkNotNil)\n+\t}\n+\treturn outWork, nil\n+}\n+\n+func (wo *WiredOperator) doSync(_ context.Context, work interface{}, state IState) IErrorPipeline {\n+\te := wo.Operator.(ISyncOperator).DoSync(wo.ctx, work, state)\n+\tif e != nil {\n+\t\treturn wo.NewError(e, work, placeDoSync)\n+\t}\n+\treturn nil\n+}\n+\n+func (wo *WiredOperator) prepare(work interface{}) (state *State, err IErrorPipeline) {\n+\tfQueryState, e := wo.Operator.Prepare(work)\n+\tif e != nil {\n+\t\terr = wo.NewError(e, work, placePrepare)\n+\t\treturn\n+\t}\n+\tif fQueryState != nil {\n+\t\tstate, e = Prepare(wo.name, work, fQueryState, wo.storages, wo.MaxPrepareQueries)\n+\t\tif e != nil {\n+\t\t\t_, _, _, _, _ = err, wo.NewError, e, work, placePrepare\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}\n","processOutput":"PASS \"C:\\\\Users\\\\ivvis\\\\AppData\\\\Local\\\\Temp\\\\go-mutesting-322536811/wired-operator.go.27\" with checksum 9a04ad13b90ca0ba502929e2c1be8680\n"}],"errored":null}